<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP</title>
    <url>/2020/05/10/AOP/</url>
    <content><![CDATA[<p>环绕前置通知  - @Before -  环绕后置通知  -  环绕返回通知 -  @After  -  @AfterReturning</p>
<p>异常结束：</p>
<p>​    环绕前置通知  - @Before -  环绕异常通知  -  环绕返回通知 -  @After  -  @AfterReturning</p>
<p>如果异常在环绕通知中解决了，那么普通通知是捕获不到的，如果想要普通通知接收到需要的异常信息，可将顺序改为：</p>
<p>环绕前置通知 -   @Before  -  环绕异常通知  -   环绕返回通知  -   @After   -   @AfterThrowing</p>
<p> try  catch  异常就捕获到了异常 ，代码可以继续向下执行</p>
<p>事务不会处理</p>
]]></content>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2020/05/11/JDBC/</url>
    <content><![CDATA[<h2 id="MySql基本语句"><a href="#MySql基本语句" class="headerlink" title="MySql基本语句"></a>MySql基本语句</h2><p>ORM(Object relational mapping)对象关系映射编程思想</p>
<ul>
<li>​    一个数据表对映一个Java类</li>
<li>​    一条记录对映一个对象</li>
<li>​    一个字段对映一个属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table &#96;orders&#96;(</span><br><span class="line">&#96;id&#96; varchar(100) not null primary key,</span><br><span class="line">&#96;order_time&#96; datetime not null,</span><br><span class="line">&#96;total_count&#96; int(11) not null,</span><br><span class="line">&#96;total_amount&#96; double(11,2) not null,</span><br><span class="line">&#96;state&#96; int(11) not null,</span><br><span class="line">&#96;user_id&#96; int(11) not null,</span><br><span class="line">constraint &#96;orders_users_id_fk&#96; foreign key</span><br><span class="line">(&#96;user_id&#96;) references &#96;users&#96;(&#96;id&#96;))</span><br><span class="line">engine&#x3D;InnoDB default charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table &#96;order_items&#96; (</span><br><span class="line">&#96;id&#96; int(11) not null primary key auto_increment,</span><br><span class="line">&#96;count&#96; int(11) not null,</span><br><span class="line">&#96;amount&#96; double(11,2) not null,</span><br><span class="line">&#96;title&#96; varchar(100) not null,</span><br><span class="line">&#96;author&#96; varchar(100) not null,</span><br><span class="line">&#96;price&#96; double(11,2) not null,</span><br><span class="line">&#96;img_path&#96; varchar(100) not null,</span><br><span class="line">&#96;order_id&#96; varchar(100) not null,</span><br><span class="line">constraint &#96;order_items_orders_id_fk&#96; foreign key</span><br><span class="line">(&#96;order_id&#96;) references &#96;orders&#96;(&#96;id&#96;) on delete cascade)</span><br><span class="line">engine&#x3D;InnoDB auto_increment&#x3D;7 default</span><br><span class="line">charset&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<p>插入数据</p>
]]></content>
  </entry>
  <entry>
    <title>algorithm03</title>
    <url>/2020/05/20/algorithm03/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>First Try</title>
    <url>/2020/05/08/First-Try/</url>
    <content><![CDATA[<h6 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h6>]]></content>
      <tags>
        <tag>First Try of Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>base</title>
    <url>/2020/05/09/base/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h3 id="方法重载和方法重写"><a href="#方法重载和方法重写" class="headerlink" title="方法重载和方法重写"></a>方法重载和方法重写</h3><h2 id="零碎细节"><a href="#零碎细节" class="headerlink" title="零碎细节"></a>零碎细节</h2><p>continue  用在循环语句中，用于跳出某一次的循环，回到循环条件判断处</p>
<p>调用某个函数的空参构造器的时候会根据继承关系自上而下的调用所有父类的空参构造器，不论子类是否有写空参构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer a = <span class="keyword">new</span> StringBuffer(<span class="string">"A"</span>);</span><br><span class="line">        StringBuffer b = <span class="keyword">new</span> StringBuffer(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">        mb_operate(a,b);</span><br><span class="line">        System.out.println(a+<span class="string">"."</span>+b);<span class="comment">//AB.B</span></span><br><span class="line">        b = a;</span><br><span class="line">        System.out.println(b);<span class="comment">//AB</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mb_operate</span><span class="params">(StringBuffer x,StringBuffer y)</span> </span>&#123;</span><br><span class="line">        x.append(y);</span><br><span class="line">        y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span>[][] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>][];</span><br><span class="line">System.out.println(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> []f1[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">//定义二维数组的两种方式</span></span><br><span class="line">System.out.println(f1.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装类是引用数据类型，所以即使Integer的默认值也是null，而不是0.</p>
<p>InputStreamReader是转换流，可以将字节流转换成字符流，是字符流与字节流之间的桥梁。他的实现使用的设计模式是：适配器模式。</p>
<p>UDP协议：</p>
<p>​    发送不管对方是否准备好，接收方收到也不确认</p>
<p>​    非常简单的协议，可以广播发送</p>
<p>取模运算：</p>
<h2 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="一-Java8之前的HashMap"><a href="#一-Java8之前的HashMap" class="headerlink" title="一.Java8之前的HashMap"></a><strong>一.Java8之前的HashMap</strong></h3><p>1.储存结构</p>
<p>HashMap是一种基于哈希表的Map接口的非同步实现类，此操作提供可选的映射操作，并允许使用null键值对，不保证映射的顺序，而且每次扩容之后会进行重新排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line"><span class="keyword">final</span> K key; </span><br><span class="line">V value; </span><br><span class="line">Entry&lt;K,V&gt; next; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//这里的hash值是key的hashcode</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<p>添加元素（put方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line"><span class="comment">// HashMap允许存放null键和null值。 </span></span><br><span class="line"><span class="comment">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 </span></span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> putForNullKey(value); </span><br><span class="line"><span class="comment">// 根据key的keyCode重新计算hash值。 </span></span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode()); </span><br><span class="line"><span class="comment">// 搜索指定hash值在对应table中的索引。 </span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length); </span><br><span class="line"><span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 </span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; </span><br><span class="line">Object k; </span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; </span><br><span class="line">V oldValue = e.value; </span><br><span class="line">e.value = value; </span><br><span class="line">e.recordAccess(<span class="keyword">this</span>); </span><br><span class="line"><span class="keyword">return</span> oldValue; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。 </span></span><br><span class="line"> modCount++; </span><br><span class="line">  <span class="comment">// 将key、value添加到i索引处。 </span></span><br><span class="line">   addEntry(hash, key, value, i); </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，<strong>新加入的放在链头，最先加入的放在链尾</strong>。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>如果该位置没有数据的话，调用addEntry方法添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 获取指定 bucketIndex 索引处的 Entry </span></span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex]; </span><br><span class="line"><span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry </span></span><br><span class="line"> table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e); </span><br><span class="line"><span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限 </span></span><br><span class="line">  <span class="keyword">if</span> (size++ &gt;= threshold) </span><br><span class="line">  <span class="comment">// 把 table 对象的长度扩充到原来的2倍。 </span></span><br><span class="line">	 resize(<span class="number">2</span> * table.length); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果有数据的话，</p>
<p>hash函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123; </span><br><span class="line">  h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>); </span><br><span class="line">  <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>根据hash函数计算出的哈希码值，来计算entry保存在数组的索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<p><a href="https://www.jianshu.com/p/ace20ab375bd" target="_blank" rel="noopener">关于HashMap</a></p>
<p><a href="https://www.jianshu.com/p/1ecd982a9480" target="_blank" rel="noopener">关于面试感悟</a></p>
<h1 id="保持知识的连贯性"><a href="#保持知识的连贯性" class="headerlink" title="保持知识的连贯性"></a>保持知识的连贯性</h1><h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>哈希表是基于数组的一种存储方式.它主要由哈希函数和数组构成。</p>
<p>当要存储一个数据的时候，首先用一个函数计算数据的地址，然后再将数据存进指定地址位置的数组里面。这个函数就是哈希函数，而这个数组就是哈希表。</p>
<p>哈希表的优势在于：相比于简单的数组以及链表，它能够根据元素本身在第一时间，也就是时间复杂度为0（1）内找到该元素的位置。这使得它在查询和删除、插入上会比数组和链表要快很多。因为他们的时间复杂度为o(n)。</p>
<p>哈希冲突是指哈希函数算出来的地址被别的元素占用了，也就是，这个位置有人了。好的哈希函数会尽量避免哈希冲突。</p>
<h2 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h2><p>有以下的方式可以解决哈希冲突：</p>
<ul>
<li>开放定址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ul>
<h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a><strong>开放定址法</strong></h4><p>这种方法的意思是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>
<p>​    <strong>线性探测再散列</strong><br>​    当发生冲突的时候，顺序的查看下一个单元</p>
<p><strong>二次(平方)探测再散列</strong><br>    当发生冲突的时候，在表的左右进行跳跃式探测</p>
<p><strong>伪随机探测再散列</strong><br>    建立一个伪随机数发生器，并给一个随机数作为起点</p>
<h4 id="再hash法"><a href="#再hash法" class="headerlink" title="再hash法"></a><strong>再hash法</strong></h4><p>这种方式是同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。<br>这种方法不易产生聚集，但增加了计算时间。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。<br>hashmap就是用此方法解决冲突的。</p>
<h4 id="建立一个公共溢出区"><a href="#建立一个公共溢出区" class="headerlink" title="建立一个公共溢出区"></a>建立一个公共溢出区</h4><p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<p>优缺点<br>开放散列（open hashing）/ 拉链法（针对桶链结构）<br>优点：</p>
<p>在总数频繁变动的时候可以节省开销，避免了动态调整；<br>记录存储在节点里，动态分布，避免了指针的开销<br>删除时候比较方便<br>缺点：</p>
<p>因为存储是动态的，所以在查询的时候跳转需要更多的时间的开销<br>在key-value可以预知，以及没有后续增改操作时候，封闭散列性能优于开放散列<br>不容易序列化<br>封闭散列（closed hashing）/ 开放定址法<br>优点：</p>
<ul>
<li><p>容易序列化</p>
</li>
<li><p>如果可以预知数据总数，可以创建完美哈希数列</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储的记录数目不能超过桶组数，在交互时候会非常麻烦</li>
<li>使用探测序列，计算时间成本过高</li>
<li>删除的时候比较麻烦</li>
</ul>
]]></content>
      <tags>
        <tag>base</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>system</title>
    <url>/2020/05/16/system/</url>
    <content><![CDATA[<p><img src="/.io//C:%5CUsers%5C%E5%88%98%E5%89%91%E7%BF%94%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516125845997.png" alt="image-20200516125845997"></p>
<p><img src="/.io//C:%5CUsers%5C%E5%88%98%E5%89%91%E7%BF%94%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516130128400.png" alt="image-20200516130128400"></p>
<p>随机访问存储器（Random-Access Memory, RAM)分为两类：静态的和动态的。静态<br>RAM(SRAM)比动态RAM(DRAM)更快，但也贵得多。SRAM 用来作为高速缓存存储<br>器，既可以在CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲<br>区。典型地，一个桌面系统的SRAM 不会超过几兆字节，但是DRAM 却有几百或几千兆<br>字节。</p>
]]></content>
      <tags>
        <tag>computer system</tag>
      </tags>
  </entry>
</search>
