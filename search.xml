<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDEA_plugins搜索不到</title>
    <url>/2020/06/05/IDEA-plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0/</url>
    <content><![CDATA[<p>因为想下载jclasslib这个插件，但是在IDEA搜索显示不出来，在晚上找了下面的解决办法。</p>
<p><img src="/2020/06/05/IDEA-plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0/figure.png" alt></p>
<p><img src="/2020/06/05/IDEA-plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0/figure01.png" alt></p>
<p>然后就是我最后实现的这种方法，说是宽带上网运营商将IDEA下载插件的网站屏蔽了，所以开手机<strong>热点</strong>连上去就可以下载了。</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优01</title>
    <url>/2020/06/02/MySQL%E8%B0%83%E4%BC%9801/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>show profiles  查看历史信息</p>
<p>show profile 查看最近一条操作</p>
<p>MySQL performance schema  性能监控  用来替代show profile</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JMM</title>
    <url>/2020/06/06/JMM/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLyog安装</title>
    <url>/2020/06/16/SQLyog%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="SQLyog12-0-9下载安装"><a href="#SQLyog12-0-9下载安装" class="headerlink" title="SQLyog12.0.9下载安装"></a>SQLyog12.0.9下载安装</h2><p>sqlyog百度云链接（永久有效）：<a href="http://pan.baidu.com/s/1i5j4GG9" target="_blank" rel="noopener">http://pan.baidu.com/s/1i5j4GG9</a> 密码：t906</p>
<p>下载后直接运行exe文件即可，为64位版本。</p>
<p>按照文档内容进行收费到免费的操作0.0</p>
<h2 id="与MySQL新建连接过程中报-2058-错误的解决"><a href="#与MySQL新建连接过程中报-2058-错误的解决" class="headerlink" title="与MySQL新建连接过程中报 2058 错误的解决"></a>与MySQL新建连接过程中报 2058 错误的解决</h2><ol>
<li><strong>以管理员身份运行命令行窗口</strong></li>
<li><strong>输入mysql检查是否配置了环境变量，没有则自行搜索方法并配置</strong></li>
<li><strong>mysql -u root -p登陆自己的本地MySQL数据库</strong></li>
<li><strong>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘yourPassword’;</strong></li>
<li><strong>重新去SQLyog建立连接</strong></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQLyog</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL中DQL、DML等概念及区别</title>
    <url>/2020/06/16/SQL%E4%B8%ADDQL%E3%80%81DML%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="SQL结构化查询语言包含6个部分"><a href="#SQL结构化查询语言包含6个部分" class="headerlink" title="SQL结构化查询语言包含6个部分"></a>SQL结构化查询语言包含6个部分</h2><p>1.数据查询语言（DQL: Data Query Language）数据检索语句，用于从表中获取数据。通常最常用的为保留字SELECT,并且常与FROM子句、WHERE子句组成查询SQL查询语句。语法：    SELECT &lt;字段名&gt; FROM &lt;表或视图名&gt; WHERE &lt;查询条件&gt;;</p>
<p>2.数据操纵语言（DML：Data Manipulation Language）主要用来对数据库的数据进行一些操作，常用的就是INSERT、UPDATE、DELETE。语法：    INSERT INTO &lt;表名&gt;(列1,列2,…) VALUES (值1,值2,…);    UPDATE &lt;表名&gt; SET &lt;列名&gt;=新值 WHERE &lt;列名&gt;=某值;    DELETE FROM &lt;表名&gt; WHERE &lt;列名&gt;=某值;</p>
<p>3.事务处理语言（DPL）事务处理语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。</p>
<p>4.数据控制语言（DCL）通过GRANT和REVOKE，确定单个用户或用户组对数据库对象的访问权限。</p>
<p>5.数据定义语言（DDL）常用的有CREATE和DROP，用于在数据库中创建新表或删除表，以及为表加入索引等。</p>
<p>6.指针控制语言（CCL）它的语句，想DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。注：   SQL是一个标准，每个数据库服务器都在标准的基础上进行了相应的调整和扩展，相应的，每个数据库对数据的各种操作语言的语法就会做出相应的调整。在MySQL中，SQL通常分为DDL、DML和查询，还包括一些其它语句类别。MySQL将SELECT与INSERT、UPDATE、DELETE分别划分到了查询和DML，但是也并非绝对的划分，通常会将SELECT与INSERT、UPDATE、DELETE一起划分为DML。具体参见MySQL官网中的MySQL Glossary.</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome插件</title>
    <url>/2020/06/02/chrome%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="插件的离线下载方式"><a href="#插件的离线下载方式" class="headerlink" title="插件的离线下载方式"></a>插件的离线下载方式</h2><ol>
<li><p>去应用商店自行下载</p>
</li>
<li><p>离线安装</p>
<p>下载需要安装 Chrome 扩展的 CRX 文件，并将其后缀名改为 ZIP 格式。然后解压缩这个 Chrome 扩展包文件。</p>
<p>点击你的 Chrome 浏览器中的「更多工具 &gt; 扩展程序」菜单或者直接在地址栏输入: chrome://extensions/ 打开扩展程序管理页面。</p>
<p>在打开的扩展程序管理页面上，选择开发者模式，点击 「加载已解压的扩展程序」。</p>
<p>选择前面解压缩的安装包所在的目录并确认后就完成了该插件的安装。</p>
</li>
</ol>
<h2 id="插件下载地址"><a href="#插件下载地址" class="headerlink" title="插件下载地址"></a>插件下载地址</h2><ul>
<li><p><strong>Crx4Chrome</strong></p>
<p>链接：<a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">https://www.crx4chrome.com/</a></p>
<p>包含了一些扩展排行，可以帮助探索新颖的好用的工具。</p>
</li>
</ul>
<ul>
<li><p><strong>扩展迷</strong></p>
<p>链接：<a href="https://extfans.com/" target="_blank" rel="noopener">https://extfans.com/</a></p>
<p>提供 Chrome 商店中优秀的 Chrome 插件推荐与下载服务。</p>
</li>
</ul>
<ul>
<li><p><strong>chrome插件网</strong></p>
<p>链接：<a href="http://chromecj.com/" target="_blank" rel="noopener">http://chromecj.com/</a></p>
<p>Chrome 插件网致力于帮助用户找到、安装、学会使用优秀的 Chrome 插件来提高谷歌浏览器的使用体验。</p>
</li>
</ul>
<h2 id="GitZip-for-Github"><a href="#GitZip-for-Github" class="headerlink" title="GitZip for Github"></a>GitZip for Github</h2><p>一个方便用户下载github资源的Chrome插件，有时候只是想要github某个仓库的部分文件而不是下载整个仓库，但原生的git命令不支持，所以在网上搜索可行的方法。</p>
<p>GitZip的使用很简单，在需要下载的仓库的某个文件或文件夹前面的空白处双击就会出现一个勾，可以选择多个文件或文件夹，这时候页面会弹出下载的按键，选择好之后点击下载即可，下载速度感觉比clone要快0.0</p>
<p>如果你觉得安装插件比较麻烦的话，也同样可以直接使用  GitZip for Github 的 Web 版本。方法类似，这里就不再赘述了。</p>
<p>Web 版本地址：<a href="https://kinolien.github.io/gitzip/" target="_blank" rel="noopener">https://kinolien.github.io/gitzip/</a></p>
<p>除了这个之外，也还有许多其他的方式来满足下载单项资源。</p>
<ul>
<li><p><a href="http://zhoudaxiaa.gitee.io/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
</li>
<li><p><a href="https://www.runoob.com/svn/tortoisesvn-intro.html" target="_blank" rel="noopener">TotoiseSVN</a></p>
</li>
<li><p><a href="https://github.com/hua1995116/git-down-repo" target="_blank" rel="noopener">git-down-repo</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install git-down-repo -g <span class="comment">// 安装全局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat  // 下载整个仓库（默认master）</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat dev // 下载某个仓库的dev分支</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/tree/master/config // 下载仓库某个文件夹</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/blob/master/config/dev.env.js // 下载某个文件</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/blob/master/config/dev.env.js https://github.com/hua1995116/webpack-plugin-inner-script/blob/master/index.js // 下载多个项目（空格分隔）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>参考：</strong><a href="https://blog.csdn.net/weixin_44058333/article/details/97138348" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44058333/article/details/97138348</a></p>
<p>​            <a href="https://cloud.tencent.com/developer/article/1463081" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1463081</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>冲浪小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>class加载过程</title>
    <url>/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%5Cflow.jog" alt></p>
<p>加载过程</p>
<h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><ol>
<li><p><strong>双亲委派，主要出于安全来考虑</strong></p>
<p><img src="/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt></p>
<p>如图所示，即先向上找寻是否已加载过该类，相应的类加载器的缓存中是否有，有就返回。如果一直没有，就自上而下查看是否能够加载。</p>
<p>该机制是由ClassLoader中的loadClass方法来实现的，loadClass方法又调用了findClass方法，所以一般来自定义classLoader重写findClass方法即可，但要打破双亲委派机制需要重写loadClass方法。</p>
<ol>
<li><p>extends ClassLoader</p>
</li>
<li><p>overwrite findClass() -&gt; defineClass(byte[] -&gt; Class clazz)</p>
</li>
<li><p>加密 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T007_ClassLoaderWithEncription</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> seed = <span class="number">0B10110110</span>;<span class="comment">//不加密就不需要这一步</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"c:/test/"</span>, name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".sriclass"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b=fis.read()) !=<span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b ^ seed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        encFile(<span class="string">"com.sri.jvm.hello"</span>);</span><br><span class="line"></span><br><span class="line">        ClassLoader l = <span class="keyword">new</span> T007_MSBClassLoaderWithEncription();</span><br><span class="line">        Class clazz = l.loadClass(<span class="string">"com.sri.jvm.Hello"</span>);</span><br><span class="line">        Hello h = (Hello)clazz.newInstance();</span><br><span class="line">        h.m();</span><br><span class="line"></span><br><span class="line">        System.out.println(l.getClass().getClassLoader());</span><br><span class="line">        System.out.println(l.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encFile</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"c:/test/"</span>, name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"c:/test/"</span>, name.replaceAll(<span class="string">"."</span>, <span class="string">"/"</span>).concat(<span class="string">".sriclass"</span>)));</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b ^ seed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>何时打破过？</p>
<ol>
<li>JDK1.2之前，自定义ClassLoader都必须重写loadClass()</li>
<li>ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定</li>
<li>热启动，热部署<ol>
<li>osgi tomcat 都有自己的模块指定classloader（可以加载同一类库的不同版本）</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>   作用：</p>
<p>   ​    1是保证了资源不浪费，使得类只加载一次。</p>
<p>   ​    2是保证了安全。比如String类型属于核心类库不能修改，这样当定义同名类的时候会向上溯源查找返回sun定义好的String，而不会覆盖。</p>
<ol start="2">
<li><p><strong>LazyLoading 五种情况</strong></p>
<p>就是用的时候才会加载</p>
<p>–new getstatic putstatic invokestatic指令，访问final变量除外</p>
<p>–java.lang.reflect对类进行反射调用时</p>
<p>–初始化子类的时候，父类首先初始化</p>
<p>–虚拟机启动时，被执行的主类必须初始化</p>
<p>–动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化</p>
</li>
</ol>
<h3 id="linking"><a href="#linking" class="headerlink" title="linking"></a>linking</h3><ul>
<li><p>verification</p>
<p>校验是否符合class文件的标准，比如cafe babe开头，符合才会往下执行</p>
</li>
<li><p>preparation</p>
<p>对静态变量赋默认值</p>
</li>
<li><p>resolution</p>
<p>将类、方法、属性等符号引用解析为直接引用</p>
<p>常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</p>
</li>
</ul>
<h3 id="initializing"><a href="#initializing" class="headerlink" title="initializing"></a>initializing</h3><p>调用类的初始化代码，给静态变量赋为初值，执行静态代码块的内容。</p>
<ol>
<li>load - 默认值 - 初始值</li>
<li>new - 申请内存 - 默认值 - 初始值</li>
</ol>
<h3 id="类加载器的范围"><a href="#类加载器的范围" class="headerlink" title="类加载器的范围"></a>类加载器的范围</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T003_ClassLoaderScope</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pathBoot = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line">        System.out.println(pathBoot.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        String pathExt = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        System.out.println(pathExt.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        String pathApp = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">        System.out.println(pathApp.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\resources.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\rt.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\sunrsasign.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jsse.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jce.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\charsets.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jfr.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\classes</span></span><br><span class="line"><span class="comment"> * --------------------</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext</span></span><br><span class="line"><span class="comment"> * C:\WINDOWS\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment"> * --------------------</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\charsets.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\deploy.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\access-bridge-64.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\cldrdata.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\dnsns.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jaccess.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jfxrt.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\localedata.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\nashorn.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunec.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunjce_provider.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunmscapi.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunpkcs11.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\zipfs.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\javaws.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jce.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jfr.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jfxswt.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jsse.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\management-agent.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\plugin.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\resources.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\rt.jar</span></span><br><span class="line"><span class="comment"> * D:\Users\Public\clone\JVM\out\production\JVM</span></span><br><span class="line"><span class="comment"> * D:\Program Files\JetBrains\IntelliJ IDEA 2019.3.2\lib\idea_rt.jar</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="lazyLoading"><a href="#lazyLoading" class="headerlink" title="lazyLoading"></a>lazyLoading</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T008_LazyLoading</span> </span>&#123; <span class="comment">//严格讲应该叫lazy initialzing，因为java虚拟机规范并没有严格规定什么时候必须loading,但严格规定了什么时候initialzing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        P p;</span><br><span class="line"><span class="comment">//        X x = new X(); // p X</span></span><br><span class="line"><span class="comment">//        System.out.println(P.i); // 8  fianl变量就不是在initializing这一步赋初始值的</span></span><br><span class="line">        System.out.println(P.j); <span class="comment">// p 9</span></span><br><span class="line"><span class="comment">//        Class.forName("com.sri.jvm.c2_classloader.T008_LazyLoading$P");</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"P"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"p+"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"X"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T012_ClassReloading2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"D:\\Users\\Public\\clone\\JVM\\out\\production\\JVM\\"</span> + name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>).concat(<span class="string">".class"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!f.exists()) <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                InputStream is = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                is.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyLoader m = <span class="keyword">new</span> MyLoader();</span><br><span class="line">        Class clazz = m.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        m = <span class="keyword">new</span> MyLoader();</span><br><span class="line">        Class clazzNew = m.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazzNew);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T006_MSBClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\Users\\Public\\clone\\JVM\\out\\production\\JVM"</span>, name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b=fis.read()) !=<span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader l = <span class="keyword">new</span> T006_MSBClassLoader();</span><br><span class="line">        Class clazz = l.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line">        Class clazz1 = l.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Hello h = (Hello)clazz.newInstance();</span><br><span class="line">        h.m();</span><br><span class="line"></span><br><span class="line">        System.out.println(l.getClass().getClassLoader());</span><br><span class="line">        System.out.println(l.getParent());</span><br><span class="line"></span><br><span class="line">        System.out.println(getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为只涉及到findClas方法的重写，其他的方法都是采用的父类或者其他类的方法，也是涉及到设计模式中的模板方法。在实现自己需要加载指定目录下的class文件，比如做框架的时候，spring  tomcat。</p>
<h2 id="java的执行"><a href="#java的执行" class="headerlink" title="java的执行"></a>java的执行</h2><p>默认是混合编译：解释执行和编译执行</p>
<p><img src="/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%5CwayToRun.jpg" alt></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>etherCAT运动控制模式</title>
    <url>/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="运动控制"><a href="#运动控制" class="headerlink" title="运动控制"></a>运动控制</h2><h3 id="什么是运动控制？"><a href="#什么是运动控制？" class="headerlink" title="什么是运动控制？"></a>什么是运动控制？</h3><p>　　运动控制就是通过机械传动装置对运动部件的位置、速度进行实时的控制管理，使运动部件按照预期的轨迹和规定的运动参数（如速度、加速度参数等）完成相应的动作。</p>
<h3 id="运动控制系统的典型构成"><a href="#运动控制系统的典型构成" class="headerlink" title="运动控制系统的典型构成"></a>运动控制系统的典型构成</h3><p>　1. 开环系统（电机：步进电机；驱动器：脉冲分配，电流放大）</p>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/%E5%BC%80%E7%8E%AF%E7%B3%BB%E7%BB%9F.png" alt></p>
<ol start="2">
<li>半闭环系统（电机：直流伺服电机、交流伺服电机；驱动器：电流放大，位置反馈控制）</li>
</ol>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/%E5%8D%8A%E9%97%AD%E7%8E%AF%E7%B3%BB%E7%BB%9F1.png" alt></p>
<pre><code>3. 半闭环系统（直流伺服电机、交流伺服电机；驱动器：速度反馈控制，电流放大；运动控制器：运动规划，速度指令，位置反馈取自电机轴）</code></pre><p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/%E5%8D%8A%E9%97%AD%E7%8E%AF%E7%B3%BB%E7%BB%9F2.png" alt></p>
<ol start="4">
<li>全闭环系统（驱动器：速度反馈控制，电流放大；运动控制器：运动规划，速度指令，位置反馈取自负载）</li>
</ol>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/%E5%85%A8%E9%97%AD%E7%8E%AF%E7%B3%BB%E7%BB%9F.png" alt></p>
<p>​        全闭环伺服系统可以消除机械传动带来的误差，而半闭环系统只能补偿部分误差，因此，半闭环伺服系统的精度比全闭环伺服系统的精度要低一些。由于采用了位置检测装置，所以全闭环系统的位置精度在其他因素确定了之后，主要取决于检测装置的分辨率和精度。</p>
<p> 　注意半闭环系统2与3的区别。驱动器如果工作在位置模式，运动控制器（运动控制卡、PLC…）就只做位置轨迹的规划（Trajectory generator），每个通信周期发送目标位置到驱动器。驱动器接收到设定位置后，与当前位置比较，并依据控制器-驱动器通信周期与驱动器位置环周期进行线性或者非线性插值，将插值作为每个位置环周期的“设定位置”。</p>
<p>　　举个例子，假设驱动器位置环周期是125us，控制器和驱动器通信周期为 2ms，当前位置为 0，目标位置为 1mm，那么接下来 16 个周期驱动器位置环的“设定位置”就依次为：0.0625mm，0.125mm， 0.1875mm， 0.25mm，……1mm. 如果没有插值，那么接下来驱动器的第 1 个周期的设定位置就是 1mm，驱动器在第 125us时，位置为 1mm，在 2-16 个周期，设定位置维持不变，相当于电机停止，直到第 2ms，接收到新的“给定位置”。由于间隔仅为 2ms，电机并不会真的停止，而是表现为顿挫感，转动不流畅，不连贯。 </p>
<p>　　驱动器如果工作在速度模式，那么控制器就不仅做位置曲线的规划，还要完成位置环的调节。此时NC周期与位置环周期相等，不必插值。伺服驱动器的位置环被忽略，其速度环直接接受上层给出的“设定速度。</p>
<h2 id="驱动器的工作模式（Modes-of-operation）"><a href="#驱动器的工作模式（Modes-of-operation）" class="headerlink" title="驱动器的工作模式（Modes of operation）"></a>驱动器的工作模式（Modes of operation）</h2><p> CANopen DSP 402协议中对象字典6060h 处定义了驱动器的工作模式：</p>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt></p>
<p>不同的驱动器支持的工作模式有所不同。比如下图分别是MAXON的EPOS2驱动器支持的模式和MAXPOS驱动器支持的工作模式（可以看出它们都遵循了CANopen 402标准）：</p>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/EPOS2.png" alt></p>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/MAXPOS.png" alt></p>
<p>本文主要介绍倍福控制器和倍福驱动器、步科驱动器、MAXPOS驱动器常用的CSP/CSV/CST这三种模式。</p>
<h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h3><p><strong>周期同步位置模式</strong></p>
<p>CSP模式下，上位机（5130）完成位置指令规划，然后将规划好的目标位置607Ah上以周期同步的方式发送给伺服驱动器，位置、速度、转矩控制由伺服驱动器内部完成。</p>
<p><img src="/2020/06/26/etherCAT%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F/csp.png" alt></p>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p><strong>周期同步速度模式</strong></p>
<p>周期同步速度模式下，控制器将计算好的目标速度 60FF 周期同步性的发送给伺服驱动器，速度、转矩调节由伺服驱动器内部执行。</p>
<h3 id="CST"><a href="#CST" class="headerlink" title="CST"></a>CST</h3><p>控制器将计算好的目标转矩 6071h 周期性同步的发送给伺服驱动器，转矩调节由伺服内部执行。当速度达到限幅后将进入调速阶段。</p>
]]></content>
      <categories>
        <category>倍福</category>
      </categories>
      <tags>
        <tag>运动控制模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaSE】权限修饰符</title>
    <url>/2020/05/30/%E3%80%90JavaSE%E3%80%91%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>Java的访问权限修饰符总共有4中，依照权限大小的顺序依次为：</p>
<ol>
<li>public</li>
<li>protected</li>
<li>friendly(default)</li>
<li>private</li>
</ol>
<p>具体权限表示可以通过下面的表格来详细描述：</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>本类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>同包其他类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>不同包其他类</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
<tr>
<td>同包子类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>不同包子类</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody></table>
<p>可以看到private用有最低的权限，该修饰符下的类、属性或是方法只能由本类使用，其他类无法访问。</p>
<p>default权限属于包权限，该包下的所有类均可以访问，但其他包的任何类都无权访问。</p>
<p>protected属于子类权限，同包下的任何类可以访问，不同包下的类如果是该类的子类仍然可以访问该权限修饰符修饰的类、属性或是方法。</p>
<p>public拥有最高权限，任何类都可以访问。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】测试图片显示问题</title>
    <url>/2020/06/03/%E3%80%90hexo%E3%80%91%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>测试图片：</p>
<p><img src="/2020/06/03/%E3%80%90hexo%E3%80%91%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/CPU_cache.jpg" alt></p>
<p>因为之前在网上看的使用npm install hexo-asset-image –save方式总是不能成功在网页上显示，但本地可以显示，就到处找解决方法一直不能成功，就换了一个插件来试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-image --save</span><br></pre></td></tr></table></figure>

<p>设置hexo配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true </span><br><span class="line"></span><br><span class="line">filter_image:</span><br><span class="line"></span><br><span class="line">  log: true</span><br></pre></td></tr></table></figure>

<p>然后在插入图片的位置输入相对路径，图片存放在和博客文章同级的同名目录下。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/06/26/git/</url>
    <content><![CDATA[<h2 id="版本控制软件的历史"><a href="#版本控制软件的历史" class="headerlink" title="版本控制软件的历史"></a>版本控制软件的历史</h2><p>1.集中化版本控制系统</p>
<p>Centralized Version Control Systems (CVCS)</p>
<p>比如：CVS, Subversion, Perforce, etc.</p>
<p>这种版本控制系统有一个单一的集中管理的服务器，保存所有文件的最新版本，大家可以通过连接到这台服务器上来获取或者提交文件。</p>
<p>​                                                                                服务器  </p>
<p>​                                                                                    |</p>
<p>​                                                             |                     |                        |</p>
<p>​                                            程序员A                         B                            C</p>
<p>2.分布式版本控制系统</p>
<p>Distributed Version Control Systems (DVCS)</p>
<hr>
<p>比如：Git, Mercurial, Bazaar, etc.</p>
<p>分布式的版本控制系统会把<strong>代码仓库完整地镜像</strong>下来，这样任何一个服务器发生故障，都可以用其他的仓库来修复。</p>
<p>更进一步，这种模式可以更方便的和不同公司的人进行同一项目的开发，因为两个远程代码仓库可以交互，这在之前的集中式系统中是无法做到的。</p>
<p><strong>那么什么叫“把代码仓库完整地镜像下来”呢？</strong></p>
<p>CVCS 每个版本存放的是当前版本与前一个版本的差异，因此也被称作基于差异的版本控制 (delta-based)；</p>
<p>Git 存储的是所有文件的一个快照 (snapshot)，如果有的文件没有修改，那就只保留一个 reference 指向之前存储的文件。</p>
<p>不是很好理解？那接着看吧～</p>
<h2 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h2><hr>
<p><strong>1.什么是快照 (snapshot) 呢？</strong></p>
<p>首先我们来学两个 Git 中的术语：</p>
<ul>
<li>blob, 就是单个的文件；</li>
<li>tree, 就是一个文件夹。</li>
</ul>
<p>快照则是被追踪的最顶层的树。</p>
<p>比如在“算法”分类下有解释、题目等分支。</p>
<p>那么一个快照就是追踪的“算法”这颗树。</p>
<p>2.本地库的数据模型</p>
<p>Git 记录了每个快照的 parent，也就是当前这个文件夹的上一个版本。</p>
<p>那么快照的迭代更新的过程就可以表示为一个<strong>有向无环图</strong>.</p>
<p><img src="/2020/06/26/git/%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt></p>
<p>每个快照其实都对应了一次<code>commit</code>，用代码表示为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commit</span> </span>&#123;</span><br><span class="line">  array&lt;commit&gt; parents</span><br><span class="line">  String author</span><br><span class="line">  String message</span><br><span class="line">  Tree snapshot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是 Git 的数据模型。</p>
<p>blob, tree, snapshot 其实都一样，它们在 Git 中都是<code>对象</code>，都可以被引用或者被搜索，会基于它们的 <code>SHA-1 hash</code> 进行寻址。</p>
<p><code>git cat-file -t</code>: 查看每个 SHA-1 的类型;<br><code>git cat-file -p</code>: 查看每个对象的内容和简单的数据结构。</p>
<p>但是通过这个哈希值来搜索也太不方便了，毕竟这是一串 40 位的十六进制字符，就是第二部分 <code>git log</code> 里输出的那个<code>编码</code>。</p>
<p>因此，Git 还给了一个引用 <code>reference</code>。</p>
<p>比如，我们常见的 <code>HEAD</code> 就是一个特殊的引用。</p>
<p>本地库就是由 <code>对象</code> 和 <code>引用</code> 构成的，或者叫 <code>Repositories</code>.</p>
<p>在硬盘上，Git 只存储 <code>对象</code> 和 <code>引用</code>，所有的 Git 命令都对应提交一个快照。</p>
<p>那有哪些常用命令呢？</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>本章分三大部分介绍日常常用命令：</p>
<ul>
<li><strong>本地操作</strong></li>
<li><strong>和远程库的交互</strong></li>
<li><strong>团队协作 - 分支</strong></li>
</ul>
<h3 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h3><p>在学习常用命令之前，你首先需要知道的 Git 的「三个分区」和对应的文件的「三种状态」：</p>
<p><img src="/2020/06/26/git/git%E5%88%86%E5%8C%BA.png" alt></p>
<ul>
<li><p><code>工作区</code>：就是你本地实际写代码的地方，无论你是用 vim 直接改也好，还是在 IDE 里写，都无所谓。</p>
</li>
<li><ul>
<li>对应的文件状态是：<code>modified</code>，已修改，但还没保存到数据库中。</li>
</ul>
</li>
<li><p><code>暂存区</code>：就是临时存放的地方。</p>
</li>
<li><ul>
<li>对应的文件状态是：<code>staged</code>，Git 已经对该文件做了标记，下次提交知道要包含它。</li>
</ul>
</li>
<li><p><code>本地库</code>：存放本地历史版本信息。</p>
</li>
<li><ul>
<li>对应的文件状态是：<code>committed</code>，文件已经安全的保存在本地数据库中。</li>
</ul>
</li>
</ul>
<h4 id="1-git-add"><a href="#1-git-add" class="headerlink" title="1. $ git add"></a>1. $ git add</h4><p>工作区改完了代码，就用 <code>git add</code> 提交到暂存区。</p>
<p>这里如果文件改动的比较多，但又不是每个都需要提交，我会设置 <code>git ignore file</code>，就表示这些文件不要提交，比如在 build project 的时候会自动生成的那些文件等等。</p>
<h4 id="2-git-commit-m-“comment”"><a href="#2-git-commit-m-“comment”" class="headerlink" title="2. $ git commit -m “comment”"></a>2. $ git commit -m “comment”</h4><p>从暂存区提交到本地库，就需要用 commit。</p>
<p>一般后面都会跟个 <code>-m</code> 加句 <code>comment</code>，简单说下改动的内容或者原因，在公司大家默认也会把 <code>Jira</code>链接附上，这样就知道这个改动对应哪个任务。</p>
<p>那如果想再改，再重新 <code>git add</code> 即可，但是 <code>commit</code> 这句需要改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>这样就还是一条 git log 信息。</p>
<h4 id="3-git-log"><a href="#3-git-log" class="headerlink" title="3. $ git log"></a>3. $ git log</h4><p><code>git log</code> 可以查看到提交过的信息，从近到远显示每次 commit 的 comment 还有作者、日期等信息，比如大概长这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">commit <span class="number">5</span>abcd17dggs9s0a7a91nfsagd8ay76875afs7d6</span><br><span class="line">Author: Xiaoqi&lt;xiaoqi@<span class="number">163</span>.com&gt;</span><br><span class="line">Date: xxx xxx xxx</span><br><span class="line">改了 Test 文件</span><br></pre></td></tr></table></figure>

<p>commit 后面的这个<code>编号</code>，是每次历史记录的一个<code>索引</code>。比如如果需要对版本进行前进或者后退的时候，就需要用到它。</p>
<p>这样打印的 log 太多，更简洁的打印方式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline</span><br></pre></td></tr></table></figure>

<p>就一行打印出来了。</p>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<p>更常用一些。</p>
<h4 id="4-git-reset"><a href="#4-git-reset" class="headerlink" title="4. $ git reset"></a>4. $ git reset</h4><p>那我们刚刚说过，如果需要前进或退回到某个版本，就用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard &lt;编号&gt;</span><br></pre></td></tr></table></figure>

<p>这样就直接跳到了这个<code>编号</code>对应的那个版本。</p>
<p>那么这个 <code>hard</code> 是什么意思呢？</p>
<p>这里有 3 个参数：<code>hard</code>, <code>soft</code>, <code>mixed</code>，我们一一来说一下。</p>
<p>回到我们最重要的这张图上来：</p>
<p><img src="/2020/06/26/git/git%E5%88%86%E5%8C%BA.png" alt></p>
<p>我们刚刚说的前进或后退到某一版本，是对<code>本地库</code>进行的操作。</p>
<p>那有个问题：<br><strong>本地库的代码跳到那个版本之后，工作区和暂存区的代码就和本地库的不同步了呀！</strong></p>
<p>那这些参数就是用来控制这些是否<strong>同步</strong>的。</p>
<h4 id="git-reset-–hard-xxx"><a href="#git-reset-–hard-xxx" class="headerlink" title="$ git reset –hard xxx"></a>$ git reset –hard xxx</h4><p>三个区都同步，都跳到这个 xxx 的版本上。</p>
<h4 id="git-reset-–soft-xxx"><a href="#git-reset-–soft-xxx" class="headerlink" title="$ git reset –soft xxx"></a>$ git reset –soft xxx</h4><p>前面两个区不同步，就只有本地库跳到这个版本。</p>
<h4 id="git-reset-–mixed-xxx"><a href="#git-reset-–mixed-xxx" class="headerlink" title="$ git reset –mixed xxx"></a>$ git reset –mixed xxx</h4><p>暂存区同步，工作区不动。</p>
<p>所以呢，用的多的就是 hard.</p>
<h3 id="远程交互"><a href="#远程交互" class="headerlink" title="远程交互"></a>远程交互</h3><p><img src="/2020/06/26/git/%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92.png" alt></p>
<p>和远程库的交互主要是<code>推</code>、<code>拉</code>，也就是写入和读取。</p>
<h4 id="5-git-push"><a href="#5-git-push" class="headerlink" title="5. $ git push"></a>5. $ git push</h4><p>小刘写完了代码，要提交到公司的代码库里，这个过程要用 <code>git push</code>.</p>
<p>当然了，这么用会被打的。。毕竟还要 cr 呢。</p>
<h4 id="5-git-clone"><a href="#5-git-clone" class="headerlink" title="5. $ git clone"></a>5. $ git clone</h4><p>新来的实习生首先要 clone 整个项目到本地来，然后才能增删改查。</p>
<p>当然了实际工作中也没人这么用。。因为每家公司都会有自己包装的工具。不过如果是做 Github 上的开源项目，就用得上了。</p>
<h4 id="6-git-pull"><a href="#6-git-pull" class="headerlink" title="6. $ git pull"></a>6. $ git pull</h4><p>小刘提交了新的代码之后，领导要审查呀，所以用 <code>git pull</code> 把最新的代码拉取下来瞅瞅。</p>
<p>实际上呢，</p>
<p><code>git pull = fetch + merge</code></p>
<h4 id="7-git-fetch"><a href="#7-git-fetch" class="headerlink" title="7. $ git fetch"></a>7. $ git fetch</h4><p><code>git fetch</code> 这个操作是将远程库的数据下载到本地库，但是工作区中的文件没有更新。</p>
<p><img src="/2020/06/26/git/fetch.png" alt="img"></p>
<p>而要谈 <code>git merge</code>，我们还需要先讲下<code>分支</code>。</p>
<p><code>merge</code> 是 <code>git pull</code> 默认的选项，合并其实还有另外一种方法：<code>rebase</code>，中文叫做<strong>变基</strong>。</p>
<h4 id="8-git-rebase"><a href="#8-git-rebase" class="headerlink" title="8. $ git rebase"></a>8. $ git rebase</h4><p>rebase 的作用更多的是来整合分叉的历史，可以将某个分支上的所有修改都移到另一分支上，就像是变了基底。</p>
<h3 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h3><p>首先我们来看几个关于分支的基本操作：</p>
<h4 id="9-查看分支："><a href="#9-查看分支：" class="headerlink" title="9. 查看分支："></a>9. 查看分支：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>

<p>类似于<code>ls</code>，能够列出当前所有分支。</p>
<p><code>git branch -v</code> 能够显示更多信息。</p>
<h4 id="10-创建分支："><a href="#10-创建分支：" class="headerlink" title="10. 创建分支："></a>10. 创建分支：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h4 id="11-切换分支："><a href="#11-切换分支：" class="headerlink" title="11. 切换分支："></a>11. 切换分支：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>有了分支之后必然会有合并：</p>
<h4 id="12-合并分支："><a href="#12-合并分支：" class="headerlink" title="12. 合并分支："></a>12. 合并分支：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>而合并时就可能会有冲突，什么时候会有冲突呢？：</p>
<p><strong>在同一个文件的同一个位置修改时。</strong></p>
<p>因为 Git 会努力的把你们改动不同的地方合并在一起，但如果实在是在同一个地方改的，那它也没办法了，只能留给程序员去手动处理了。</p>
<p>当然了，每个命令延伸下去还有无限多个，本文不可能涵盖全部，所以在此重磅推荐齐姐精心挑选的三大学习资源，大家可以自行享用～</p>
<p>​                                                                            <strong>学习资源</strong></p>
<hr>
<ul>
<li><p>git help</p>
</li>
<li><p>pro git</p>
<p>英文版：</p>
<p><code>https://git-scm.com/book/en/v2</code></p>
<p>中文版：</p>
<p><code>https://git-scm.com/book/zh/v2</code></p>
</li>
<li><p>玩游戏</p>
<p>Practice makes perfect!</p>
<p>推荐一个宝藏资源：玩游戏来练 Git</p>
<p>项目：<code>https://github.com/pcottle/learnGitBranching</code></p>
<p>网址：<code>https://learngitbranching.js.org/</code></p>
</li>
</ul>
<p>我熟悉很多工具都是通过小游戏来练习的，比如 vim 的操作，还是蛮推荐这种方式的。就不剧透啦，大家自己去探索吧～</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/l9svfi6nezphazmXF1-vnQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/l9svfi6nezphazmXF1-vnQ</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/06/08/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h2><p>先序：头 -  左 - 右</p>
<p>中序：左 - 头 - 右</p>
<p>后序：左 - 右 - 头</p>
<h3 id="用-栈-实现二叉树的先序-中序-后续-遍历"><a href="#用-栈-实现二叉树的先序-中序-后续-遍历" class="headerlink" title="用 栈 实现二叉树的先序 中序 后续 遍历"></a>用 栈 实现二叉树的先序 中序 后续 遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> Node left;</span><br><span class="line">   <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">      value = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      stack.add(head);</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">         head = stack.pop();</span><br><span class="line">         System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">         <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head.right);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head.left);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.right;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个栈实现后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      s1.push(head);</span><br><span class="line">      <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">         head = s1.pop();</span><br><span class="line">         s2.push(head);</span><br><span class="line">         <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(head.left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(head.right);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">         System.out.print(s2.pop().value + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个栈实现后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos2</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      stack.push(h);</span><br><span class="line">      Node c = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">         c = stack.peek();</span><br><span class="line">         <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">            stack.push(c.left);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; h != c.right) &#123;</span><br><span class="line">            stack.push(c.right);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">            h = c;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以队列实现二叉树的按层遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">level</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   queue.add(head);</span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      Node cur = queue.poll();<span class="comment">//linkedList方法，返回队头的节点并释放</span></span><br><span class="line">      System.out.println(cur.value);</span><br><span class="line">      <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用Map实现返回二叉树的最大宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthUseMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   queue.add(head);</span><br><span class="line">   <span class="comment">// key 在 哪一层，value</span></span><br><span class="line">   HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> curLevel = <span class="number">1</span>; <span class="comment">// 当前你正在统计哪一层的宽度</span></span><br><span class="line">   <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      Node cur = queue.poll();</span><br><span class="line">      <span class="keyword">int</span> curNodeLevel = levelMap.get(cur);</span><br><span class="line">      <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">         curLevelNodes++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         max = Math.max(max, curLevelNodes);</span><br><span class="line">         curLevel++;</span><br><span class="line">         curLevelNodes = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   max = Math.max(max, curLevelNodes);</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不是用Map实现返回二叉树的最大宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   queue.add(head);</span><br><span class="line">   Node curEnd = head; <span class="comment">// 当前层，最右节点是谁</span></span><br><span class="line">   Node nextEnd = <span class="keyword">null</span>; <span class="comment">// 下一层，最右节点是谁</span></span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      Node cur = queue.poll();</span><br><span class="line">      <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">         nextEnd = cur.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">         nextEnd = cur.right;</span><br><span class="line">      &#125;</span><br><span class="line">      curLevelNodes++;</span><br><span class="line">      <span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">         max = Math.max(max, curLevelNodes);</span><br><span class="line">         curLevelNodes = <span class="number">0</span>;</span><br><span class="line">         curEnd = nextEnd;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，</span></span><br><span class="line"><span class="comment"> * 以下代码全部实现了。</span></span><br><span class="line"><span class="comment"> * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化</span></span><br><span class="line"><span class="comment"> * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。</span></span><br><span class="line"><span class="comment"> * 比如如下两棵树</span></span><br><span class="line"><span class="comment"> *         __2</span></span><br><span class="line"><span class="comment"> *        /</span></span><br><span class="line"><span class="comment"> *       1</span></span><br><span class="line"><span class="comment"> *       和</span></span><br><span class="line"><span class="comment"> *       1__</span></span><br><span class="line"><span class="comment"> *          \</span></span><br><span class="line"><span class="comment"> *           2</span></span><br><span class="line"><span class="comment"> * 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125;</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>

<p>序列化和反序列化，将二叉树的节点值按照字符串保存下来，并保存它的数据结构信息以便重构回内存，空的节点以null值补齐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">preSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   pres(head, ans);</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pres</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ans.add(<span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ans.add(String.valueOf(head.value));</span><br><span class="line">      pres(head.left, ans);</span><br><span class="line">      pres(head.right, ans);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序反序列化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByPreQueue</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (prelist == <span class="keyword">null</span> || prelist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> preb(prelist);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">preb</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>&#123;</span><br><span class="line">		String value = prelist.poll();</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">		head.left = preb(prelist);</span><br><span class="line">		head.right = preb(prelist);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">posSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   poss(head, ans);</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">poss</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ans.add(<span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      poss(head.left, ans);</span><br><span class="line">      poss(head.right, ans);</span><br><span class="line">      ans.add(String.valueOf(head.value));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序反序列化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByPosQueue</span><span class="params">(Queue&lt;String&gt; poslist)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (prelist == <span class="keyword">null</span> || prelist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="comment">// 左右中  -&gt;  stack(中右左)</span></span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!poslist.isEmpty()) &#123;</span><br><span class="line">			stack.push(poslist.poll());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> posb(stack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">posb</span><span class="params">(Stack&lt;String&gt; posstack)</span> </span>&#123;</span><br><span class="line">		String value = posstack.pop();</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">		head.right = posb(posstack);</span><br><span class="line">		head.left = posb(posstack);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">levelSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">      Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">         ans.add(<span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         ans.add(String.valueOf(head.value));</span><br><span class="line">         Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">         queue.add(head);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(String.valueOf(head.left.value));</span><br><span class="line">               queue.add(head.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(String.valueOf(head.right.value));</span><br><span class="line">               queue.add(head.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按层反序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByLevelQueue</span><span class="params">(Queue&lt;String&gt; levelList)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (levelList == <span class="keyword">null</span> || levelList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Node head = generateNode(levelList.poll());</span><br><span class="line">      Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">      <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(head);</span><br><span class="line">      &#125;</span><br><span class="line">      Node node = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">         node = queue.poll();</span><br><span class="line">         node.left = generateNode(levelList.poll());</span><br><span class="line">         node.right = generateNode(levelList.poll());</span><br><span class="line">         <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归序"><a href="#递归序" class="headerlink" title="递归序"></a>递归序</h3><h3 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h3><h3 id="获取二叉树某个节点的后继节点"><a href="#获取二叉树某个节点的后继节点" class="headerlink" title="获取二叉树某个节点的后继节点"></a>获取二叉树某个节点的后继节点</h3><p>重新定义二叉树的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Node &#123;</span><br><span class="line"></span><br><span class="line"> 	V value;</span><br><span class="line"></span><br><span class="line"> 	Node left;</span><br><span class="line"></span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	Node parent;<span class="comment">//多定义了指向父节点的指针</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后继节点即为整棵二叉树以中序遍历输出之后，当前节点的下一个输出节点。</p>
<p>因此暴力解法可以通过父节点指针找到头结点，将整棵二叉树中序遍历来得到顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> Node left;</span><br><span class="line">   <span class="keyword">public</span> Node right;</span><br><span class="line">   <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无右子树</span></span><br><span class="line">      Node parent = node.parent;</span><br><span class="line">      <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.right == node) &#123; <span class="comment">// 当前节点是其父亲节点右孩子</span></span><br><span class="line">         node = parent;</span><br><span class="line">         parent = node.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> parent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			node = node.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取二叉树某个节点的前驱节点"><a href="#获取二叉树某个节点的前驱节点" class="headerlink" title="获取二叉树某个节点的前驱节点"></a>获取二叉树某个节点的前驱节点</h3><p>前驱节点，即后继节点概念下，当前节点的前一个输出。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p>
<p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 </p>
<p>例如:N=2时，打印: down down up   凹凹凸</p>
<p>观察可以得知，每次折痕的上部距已有折痕1/2处会出现凹折痕，下部距已有折痕1/2处会出现凸折痕。可以以二叉树的结构来表示。</p>
<p><img src="/2020/06/08/%E4%BA%8C%E5%8F%89%E6%A0%91/Folder.png" alt></p>
<p>这颗二叉树的所有左子树都是凹折痕，右子树都是凸折痕。想要将纸上的折痕方向自上而下打印，即将这颗二叉树进行中序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">   printProcess(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归过程，来到了某一个节点，</span></span><br><span class="line"><span class="comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">   System.out.println(down ? <span class="string">"凹 "</span> : <span class="string">"凸 "</span>);</span><br><span class="line">   printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿递归模拟出了这颗二叉树。空间复杂度只需要一个递归栈O(N).</p>
<h2 id="二叉树的递归方法"><a href="#二叉树的递归方法" class="headerlink" title="二叉树的递归方法"></a>二叉树的递归方法</h2><h3 id="二叉树的递归套路流程"><a href="#二叉树的递归套路流程" class="headerlink" title="二叉树的递归套路流程"></a>二叉树的递归套路流程</h3><ul>
<li>1）假设以X节点为头，假设可以向X左树和X右树要任何信息</li>
<li>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</li>
<li>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</li>
<li>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S   因为是递归，所以不想要区分左右子树</li>
<li>5）递归函数都返回S，每一棵子树都这么要求</li>
<li>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</li>
</ul>
<h3 id="返回是否平衡二叉树"><a href="#返回是否平衡二叉树" class="headerlink" title="返回是否平衡二叉树"></a>返回是否平衡二叉树</h3><p>平衡二叉树：</p>
<p>​    节点左子树和右子树的高度差不大于1，必须所有子树的满足这个要求，整棵树才称为平衡二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> Node left;</span><br><span class="line">   <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span>[] ans = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">   ans[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">   process1(head, ans);</span><br><span class="line">   <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(Node head, <span class="keyword">boolean</span>[] ans)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!ans[<span class="number">0</span>] || head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> leftHeight = process1(head.left, ans);</span><br><span class="line">		<span class="keyword">int</span> rightHeight = process1(head.right, ans);</span><br><span class="line">		<span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			ans[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>第二种方式</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> process2(head).isBalaced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左、右要求一样，Info 信息返回的结构体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为我的要求是左子树和右子树首先得是平衡二叉树，然后看以我当前节点为头结点，二者的高度差</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> isBalaced;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">      isBalaced = b;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process2</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//空节点了嘛，当然是平衡的了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Info leftInfo = process2(X.left);</span><br><span class="line">   Info rightInfo = process2(X.right);</span><br><span class="line">   <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果</span></span><br><span class="line">    <span class="comment">//左子树不平衡 或者 右子树不平衡 或者 二者的高度差大于1</span></span><br><span class="line">    <span class="comment">//返回当前二叉树不平衡</span></span><br><span class="line">   <span class="keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      isBalanced = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateRandomBST</span><span class="params">(<span class="keyword">int</span> maxLevel, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> generate(<span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generate</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> maxLevel, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (level &gt; maxLevel || Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Node head = <span class="keyword">new</span> Node((<span class="keyword">int</span>) (Math.random() * maxValue));</span><br><span class="line">   head.left = generate(level + <span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">   head.right = generate(level + <span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxLevel = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> testTimes = <span class="number">1000000</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">      Node head = generateRandomBST(maxLevel, maxValue);</span><br><span class="line">      <span class="keyword">if</span> (isBalanced1(head) != isBalanced2(head)) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Oops!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">"finish!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="返回节点的最大距离"><a href="#返回节点的最大距离" class="headerlink" title="返回节点的最大距离"></a>返回节点的最大距离</h3><p>稍难的是列出所有可能性</p>
<p>以是否考虑头结点来划分成两个大类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> dis, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">      maxDistance = dis;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Info leftInfo = process(X.left);</span><br><span class="line">   Info rightInfo = process(X.right);</span><br><span class="line">   <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> maxDistance = Math.max(</span><br><span class="line">         Math.max(leftInfo.maxDistance, rightInfo.maxDistance),</span><br><span class="line">         leftInfo.height + rightInfo.height + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Info(maxDistance, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大二叉搜索子树"><a href="#最大二叉搜索子树" class="headerlink" title="最大二叉搜索子树"></a>最大二叉搜索子树</h3><p>Binary Search Tree</p>
<p>搜索二叉树</p>
<p><code>BST</code> 整棵树没有重复值(好像是废话 - -），每棵树的左节点比头节点小，右节点比头节点大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBSTSize</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ArrayList&lt;Node&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   in(head, arr);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.get(i).value &lt;= arr.get(i - <span class="number">1</span>).value) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head, ArrayList&lt;Node&gt; arr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   in(head.left, arr);</span><br><span class="line">   arr.add(head);</span><br><span class="line">   in(head.right, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubBSTSize1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> h = getBSTSize(head);</span><br><span class="line">   <span class="keyword">if</span> (h != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Math.max(maxSubBSTSize1(head.left), maxSubBSTSize1(head.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubBSTSize2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> process(head).maxSubBSTSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 任何子树</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> isAllBST;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> maxSubBSTSize;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> is, <span class="keyword">int</span> size, <span class="keyword">int</span> mi, <span class="keyword">int</span> ma)</span> </span>&#123;</span><br><span class="line">			isAllBST = is;</span><br><span class="line">			maxSubBSTSize = size;</span><br><span class="line">			min = mi;</span><br><span class="line">			max = ma;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(X == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo = process(X.left);</span><br><span class="line">		Info rightInfo = process(X.right);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> min = X.value;</span><br><span class="line">		<span class="keyword">int</span> max = X.value;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			min = Math.min(min, leftInfo.min);</span><br><span class="line">			max = Math.max(max, leftInfo.max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			min = Math.min(min, rightInfo.min);</span><br><span class="line">			max = Math.max(max, rightInfo.max);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> maxSubBSTSize = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			maxSubBSTSize = leftInfo.maxSubBSTSize;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rightInfo !=<span class="keyword">null</span>) &#123;</span><br><span class="line">			maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(</span><br><span class="line">				<span class="comment">// 左树整体需要是搜索二叉树</span></span><br><span class="line">				(  leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST    )</span><br><span class="line">				&amp;&amp;</span><br><span class="line">				(  rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST    )</span><br><span class="line">				&amp;&amp;</span><br><span class="line">				<span class="comment">// 左树最大值&lt;x</span></span><br><span class="line">				(leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.max &lt; X.value)</span><br><span class="line">				&amp;&amp;</span><br><span class="line">				(rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.min &gt; X.value)</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">				) &#123;</span><br><span class="line">			</span><br><span class="line">			maxSubBSTSize = </span><br><span class="line">					(leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize)</span><br><span class="line">					+</span><br><span class="line">					(rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize)</span><br><span class="line">					+</span><br><span class="line">					<span class="number">1</span>;</span><br><span class="line">					isAllBST = <span class="keyword">true</span>;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(isAllBST, maxSubBSTSize, min, max);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h3 id="排队最大快乐值"><a href="#排队最大快乐值" class="headerlink" title="排队最大快乐值"></a>排队最大快乐值</h3><p>描述：</p>
<p>公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p>
<p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</p>
<p>1.如果某个员工来了，那么这个员工的所有<strong>直接</strong>下级都不能来</p>
<p>2.派对的整体快乐值是所有到场员工快乐值的累加</p>
<p>3.你的目标是让派对的整体快乐值尽量大</p>
<p>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</p>
<p>员工信息的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> happy; <span class="comment">// 这名员工可以带来的快乐值</span></span><br><span class="line"></span><br><span class="line">  List&lt;Employee&gt; subordinates; <span class="comment">// 这名员工有哪些直接下级</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappy1</span><span class="params">(Employee boss)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (boss == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> process1(boss, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(Employee cur, <span class="keyword">boolean</span> up)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (up) &#123;</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Employee next : cur.nexts) &#123;</span><br><span class="line">         ans += process1(next, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> p1 = cur.happy;</span><br><span class="line">      <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Employee next : cur.nexts) &#123;</span><br><span class="line">         p1 += process1(next, <span class="keyword">true</span>);</span><br><span class="line">         p2 += process1(next, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappy2</span><span class="params">(Employee boss)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (boss == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Info all = process2(boss);</span><br><span class="line">   <span class="keyword">return</span> Math.max(all.yes, all.no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> yes;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      yes = y;</span><br><span class="line">      no = n;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process2</span><span class="params">(Employee x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x.nexts.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Info(x.happy, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> yes = x.happy;</span><br><span class="line">   <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (Employee next : x.nexts) &#123;</span><br><span class="line">      Info nextInfo = process2(next);</span><br><span class="line">      yes += nextInfo.no;</span><br><span class="line">      no += Math.max(nextInfo.yes, nextInfo.no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Info(yes, no);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/05/30/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>值传递：</p>
<p>​    java参数传递采用的是值传递，对于<strong>基本类型的变量</strong>，相当于直接将变量进行了拷贝，在方法内部改变了变量i的值也不会影响方法外的i。</p>
<p>​    对于引用变量，传递的是引用的值，也就是说让实参和形参同时指向了同一个对象，因此让形参重新指向另一个对象对实参并没有任何影响。</p>
<p>简单定义：定义在一个类内部的类就叫内部类。</p>
<p>内部类也是一个很困惑的点了。</p>
<p>首先是分类，内部类可以按照所在区域的不同分为以下四种：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态内部类</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>参考：<a href="https://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenssy/p/3388487.html</a></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h2 id="内部类详解"><a href="#内部类详解" class="headerlink" title="内部类详解"></a>内部类详解</h2><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】next导航栏404</title>
    <url>/2020/06/03/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404/</url>
    <content><![CDATA[<p>去查看了public下的index.html代码，发现所有导航路径后都有%20，%20代表空格，而这个一部分又是next主题中生成的，去查看了配置文件，将配置文件里 ||之前所有的空格删掉。</p>
<p><img src="/2020/06/03/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404/pic1.jpg" alt></p>
<p>然后重新生成静态文件并部署即可。</p>
<p>侧边栏的链接可能也有404的问题，直接去主题目录下找相应名称的配置文件进行修改即可。</p>
<p>如果没有标签和分类页面，可以通过 hexo new page tags这样的命令在source下创建文件夹，并修改index.md<br>如下，冒号后面有空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【javaSE】关键字</title>
    <url>/2020/05/26/%E3%80%90javaSE%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Java关键字是预先定义好的，有特殊意义的标识符。在Java语言中关键字一律小写。关键字不可以用作变量名、方法名、类名、包名和参数类型。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>assert</td>
<td>断言</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>break</td>
<td>用于在循环语句中跳出当前循环或配合label使用</td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>continue</td>
<td>跳过<strong>本次</strong>循环执行，到下一次循环开始处</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中，必执行一次循环体</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型，浮点数默认类型</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>enum</td>
<td>定义枚举类</td>
</tr>
<tr>
<td>extends</td>
<td>继承，可以继承类或者抽象类，不能继承接口，继承抽象类的抽象方法也必须重写，但是抽象类里面的未声明abstract的方法可不重写</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
</tr>
<tr>
<td>finally</td>
<td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型，使用的时候数字后面跟f或F</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>implements</td>
<td>实现，Java多实现</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据，也可用在循环中，但是就直接跳出该方法了</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>strictfp</td>
<td>strict float point 精确浮点</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>synchronized</td>
<td>同步</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常，方法体内</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前成员方法中所有需要抛出的异常，在方法声明处，异常用,隔开</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>const</td>
<td>用于修改字段或局部变量的声明。它指定字段或局部变量的值是常数，不能被修改</td>
</tr>
<tr>
<td>goto</td>
<td>指定跳转到标签，找到标签后，程序将处理从下一行开始的命令</td>
</tr>
<tr>
<td>true</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>static主要有四种使用场景</strong></p>
<ul>
<li><p><strong>修饰成员变量和成员方法：</strong>被static修饰的成员变量或方法属于当前的类，而非某个特定的实例对象，被类的所有对象共享。可以通过类名调用，成员变量属于静态成员变量，存放在Java内存区域中的方法区。</p>
</li>
<li><p><strong>静态代码块：</strong>静态代码块定义在类中的方法外，静态代码块在非静态代码块之前执行（静态代码块-&gt;非静态代码块-&gt;构造方法）。静态代码块只会执行一次，不论该类创造了多少对象。</p>
</li>
<li><p><strong>静态内部类（static可以修饰类，但是只能修饰内部类）：</strong>静态内部类与非静态内部类之间存在一个最大的区别是：非静态内部类在编译完成之后会隐式地保存着一个引用，<strong>该引用指向创建它的外部类</strong>，但是静态内部类是在外部类加载的时候也加载的，并没有这个隐含地引用。没有这个引用也就意味着：1.它的创建是不需要依赖外部类的创建。2.它不能使用外部类得到非static成员变量和成员方法。因为静态嘛，静态无法使用非静态的东西。</p>
</li>
<li><p><strong>静态导包（用来导入类中的静态资源，1.5之后的新特性）：</strong>格式为import static …</p>
<p> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中的静态成员，可以直接使用类中的静态成员变量和成员方法。也就是说本来在该类中可以通过</p>
<p>类名.静态方法() 类名.静态变量  的方式来调用，现在不需要加上类名.这个前缀了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_01</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">static_01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"非静态代码块，也称构造代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"共有的静态方法"</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"静态方法中的非静态代码块"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"main方法体"</span>);</span><br><span class="line">		 &#123;</span><br><span class="line">			 System.out.println(<span class="string">"main方法非静态代码块"</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 static_01 o1 = <span class="keyword">new</span> static_01();</span><br><span class="line">		 o1.method01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_02</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		static_01 o2 = <span class="keyword">new</span> static_01();</span><br><span class="line">		static_01 o3 = <span class="keyword">new</span> static_01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行该类main方法结果为：</span><br><span class="line"></span><br><span class="line">静态代码块</span><br><span class="line">main方法体</span><br><span class="line">main方法非静态代码块</span><br><span class="line">非静态代码块，也称构造代码块</span><br><span class="line">构造方法</span><br><span class="line">共有的静态方法</span><br><span class="line">静态方法中的非静态代码块</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">可以看到静态代码块是首先执行的，而非静态代码块是在创建对象的时候才执行，而如果静态代码块已经执行过就不会再执行了，而非静态代码块在每创建一个对象的时候都会执行。</span><br></pre></td></tr></table></figure>

<p>非静态代码块与构造函数的区别是：非静态代码块是给所有对象进行统一的初始化，而构造函数是给对应的对象初始化，因构造函数是可以多个的，运行什么样的构造函数创建什么样的对象，但是无论创建哪个对象都会执行相同的构造代码块。共性和个性的区别。</p>
<p><strong>补充：</strong></p>
<p>关于Class.forName方法加载类</p>
<p>查看API可知，调用Class.forName(“package.className”)的方式实际上是等价于调用Class.forName(className, true, currentLoader)  (ClassLoader.getSystemClassLoader())</p>
<p>因此在加载类的时候就做了类的初始化操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;static_01&gt; clazz = static_01<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//只是单纯的加载类，不会初始化，即没有使用数据</span></span><br><span class="line">            static_01 static_01 = static_01<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;<span class="comment">//静态代码块-非静态代码块-构造方法</span></span><br><span class="line"><span class="comment">//            static_01 s1 = new static_01();</span></span><br><span class="line"><span class="comment">//            static_01 s2 = new static_01();</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"shu.keyWords.static_01"</span>,<span class="keyword">false</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码取消初始化操作之后就不会执行静态代码块，只是将类加载成字节码文件。</p>
<p>其中new是强类型，相对高效，能调用任何public构造方法。newInstance是弱类型，相对低效，只能调用无参构造。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li><p><strong>final修饰变量，则等同于常量</strong>.</p>
<p>​        final修饰变量是使用最多的地方。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能指向另一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Person person;</span><br><span class="line">    <span class="comment">//如果同时加了static 和 final 就必须立刻赋初始值，因为static在构造方法之前加载的</span></span><br><span class="line"><span class="comment">//只加其中一个修饰关键字是都可以在构造方法赋值的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">        person.setAge(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//    public FinalTest01() &#123;</span></span><br><span class="line"><span class="comment">//        super();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//这个时候会报错，也就是说所有的构造方法都必须对这个final成员变量赋值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalTest finalTest = <span class="keyword">new</span> FinalTest(<span class="keyword">new</span> Person());</span><br><span class="line">        System.out.println(finalTest.person.getAge());<span class="comment">//11</span></span><br><span class="line">        finalTest.person.setAge(<span class="number">13</span>);</span><br><span class="line">        System.out.println(finalTest.person.getAge());<span class="comment">//13</span></span><br><span class="line">        <span class="comment">//final成员变量必须让所有的构造方法赋初始值，且引用类型变量地址值不可变，变量的内部属性可以通过自己的方法来改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">    在某偏博客还是帖子看到的例子：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = <span class="string">"hello"</span>;</span><br><span class="line">        String d = <span class="string">"hello"</span>;</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        String e = d + <span class="number">2</span>;</span><br><span class="line">        System.out.println((a == c));</span><br><span class="line">        System.out.println((a == e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出结果：true、false</span></span><br><span class="line"><span class="comment">     大家可以先想一下这道题的输出结果。为什么第一个比较结果为true，而第二个比较结果为fasle。这里面就是final变量和普通变量的区别了，当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。因此在上面的一段代码中，由于变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b 替换为它的值。而对于变量d的访问却需要在运行时通过链接来进行。想必其中的区别大家应该明白了，不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化，比如下面的这段代码就不会进行优化：    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = getHello();</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        System.out.println((a == c));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码的输出结果为false。这里要注意一点就是：不要以为某些数据是final就可以在编译期知道其值，通过变量b我们就知道了，在这里是使用getHello()方法对其进行初始化，他要在运行期才能知道其值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final修饰方法参数列表中的参数，称为最终参数。</strong></p>
</li>
<li><p><strong>final修饰类，则类不能被继承</strong>。final类中的所有成员方法都会被隐式地指定为final方法。</p>
</li>
<li><p><strong>final修饰方法，则方法不能被重写。</strong></p>
<p>​        使用final修饰方法的原因有两个，1是将方法锁定，以防止任何继承类修改它的含义；2是因为效率，在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能会看不到内嵌调用带来的性能提升。现在的版本已经不需要使用final来进行这样的优化了，类中所有的private方法都会隐式地指定为final。</p>
<p>　    因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即<strong>父类的final方法是不能被子类所覆盖的</strong>，也就是说子类是不能够存在和父类一模一样的方法的。</p>
<pre><code>final修饰的方法表示此方法已经是“**最后的、最终的**”含义，亦即**此方法不能被重写**（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</code></pre></li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this关键字用于引用当前类的<strong>实例</strong>。</p>
<p>所以要注意哪些地方才可以使用this关键字。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super关键字用于从子类访问父类的变量和方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>底层基础知识01</title>
    <url>/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>计算机需要解决的最根本问题其实是：如何代表数字</p>
<h2 id="汇编语言（机器语言）的执行过程"><a href="#汇编语言（机器语言）的执行过程" class="headerlink" title="汇编语言（机器语言）的执行过程"></a>汇编语言（机器语言）的执行过程</h2><p>汇编语言的本质是机器语言的助记符，其实就是机器语言。</p>
<p>使用一些便于人理解的符号来表示一些操作，比如add sub等。</p>
<p>执行流程：</p>
<p>​        计算机通电-&gt; CPU读取内存中的程序（电信号输入） -&gt; <strong>时钟发生器</strong>不断的震荡通断电 -&gt; 推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期） -&gt; 计算完成 -&gt; 写回（电信号）   -&gt; 写给显卡输出</p>
<h2 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h2><p>PC ： Program Counter 程序计数器（记录当前指令地址）</p>
<p>​        记录当前指令占位多少，来推断下一指令的位置。</p>
<p>Register（寄存器） ： 暂时储存CPU计算需要用到的数据</p>
<p>ALU ： Arithmetic &amp; Logic Unit 运算和逻辑单元</p>
<p>CU ： Control Unit 控制单元</p>
<p>MMU ： Memory Management Unit 内存管理单元</p>
<p>Cache : L1 L2 L3(多核共享)</p>
<h2 id="CPU的制作与原理"><a href="#CPU的制作与原理" class="headerlink" title="CPU的制作与原理"></a>CPU的制作与原理</h2><p><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="noopener">https://www.sohu.com/a/255397866_468626</a></p>
<p><a href="https://www.bilibili.com/video/av47388949?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av47388949?p=2</a></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-CPU缓存层次"><a href="#1-CPU缓存层次" class="headerlink" title="1.CPU缓存层次"></a>1.CPU缓存层次</h3><p>现代CPU的储存结构如下图所示。</p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/CPU_cache.jpg" alt></p>
<p>SRAM: Static Random-Access Memory 静态随机存取器。静态是指只要保持通电状态，其内储存的数据就能恒常保持。</p>
<p>DRAM： Dynamic Random Access Memory动态随机存取储存器。动态指其内的数据需要周期性的更新，否则会导致数据出错。</p>
<p>为了缓和CPU运算速度远快于从内存读取数据的速度的矛盾，引入了缓存。</p>
<ul>
<li>L1高速缓存：也叫一级缓存。一般内置在内核旁边，是与CPU结合最为紧密的CPU缓存。一次访问只需要2~4个时钟周期</li>
<li>L2高速缓存：也叫二级缓存。空间比L1缓存大，速度比L1缓存略慢。一次访问约需要10多个时钟周期</li>
<li>L3高速缓存：也叫三级缓存。部分单CPU多核心的才会有的缓存，介于多核和内存之间。存储空间已达Mb级别，一次访问约需要数十个时钟周期</li>
</ul>
<p>对于多核处理器，L3是每个CPU内共享的，L1 L2 及寄存器是每个核独有的。</p>
<h3 id="总线锁及缓存锁"><a href="#总线锁及缓存锁" class="headerlink" title="总线锁及缓存锁"></a>总线锁及缓存锁</h3><p>总线锁：锁住总线。通过处理器发出lock指令，总线接收到指令后，其他处理器的请求就会被阻塞，直到此处理器执行完成。这样处理器可以独占共享内存，但因此其他的处理器就只能阻塞等待，无法发挥多处理的优势。</p>
<p>缓存锁：锁定被缓存的共享对象。接收到lock指令，通过缓存一致性协议，维护本处理器内部缓存和其他处理器缓存的一致性。</p>
<h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>虽然每次CPU需要使用的数据可能只有一小块，但是因为程序运行的局部性原理，提出了缓存行的概念。即一次读取一块内存数据放入缓存，即为缓存行。缓存行（cache line）是CPU缓存中可分配、操作的最小存储单元，与CPU的架构相关，通常有32字节、64字节、128字节等。经过大量实验取折中值为64字节。</p>
<ul>
<li>缓存行越大，局部性空间效率越高，但读取的时间就慢</li>
<li>缓存行越小，局部性空间效率越低，但读取的时间就快</li>
</ul>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>每个CPU都有自己的高速缓存，但又共享同一个主存。当多个处理器都涉及同一块主存区域的更改时，将导致各自的缓存数据不一致。因此提出缓存一致性协议来保证各处理器读取数据的一致性。</p>
<p>每个CPU厂商可能都有自己的缓存一致性协议。例如Intel的MESI协议。其他还有MSI、MOSI、MESIF、Synapse Firefly Dragon等。</p>
<p>MESI(Modified Exclusive Shared Or Invalid)</p>
<p><strong>MESI的状态</strong></p>
<p>CPU中的每个cache line使用4种状态标记（使用额外的两位(bit)来表示）：</p>
<p><strong>M：被修改（Modified）</strong></p>
<p>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，即与主存中的数据不一致，该缓存行中的内存需要在未来某个时间点写回主存。</p>
<p><strong>E：独享的(Exclusive)</strong></p>
<p>该缓存行<strong>只被缓存在该CPU的缓存</strong>中，<strong>它是未被修改过的，与主存中的数据一致</strong>。该状态可在任何时刻当有其他CPU读取该内存时变成共享状态（shared）。</p>
<p><strong>S：共享的（shared）</strong></p>
<p>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致，当有一个CPU修改该缓存行中的数据时，其他CPU中该缓存行可以被作废，变为Invalid状态。</p>
<p><strong>I：无效的（Invalid）</strong></p>
<p>该缓存是无效的（可能有其他CPU修改了该缓存行）</p>
<p>状态转换图及流程表</p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/MESI_pic.jpg" alt></p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/mesi_chart.png" alt></p>
<p>在一个典型系统中，可能会有几个缓存（在多核系统中，每个核心都会有自己的缓存）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了减少<code>CPU</code>读写共享主存的次数。</p>
<p>一个缓存除在<code>Invalid</code>状态外都可以满足cpu的读请求，一个<code>Invalid</code>的缓存行必须从主存中读取（变成<code>S</code>或者 <code>E</code>状态）来满足该<code>CPU</code>的读请求。</p>
<p>一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于<code>S</code>状态，必须先将其它缓存中该缓存行变成<code>Invalid</code>状态（也既是不允许不同<code>CPU</code>同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：<code>RequestFor Ownership</code> (<code>RFO</code>)。</p>
<p>缓存可以随时将一个非M状态的缓存行作废，或者变成<code>Invalid</code>状态，而一个<code>M</code>状态的缓存行必须先被写回主存。</p>
<p>一个处于<code>M</code>状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。</p>
<p>一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（<code>Invalid</code>）。</p>
<p>一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成<code>S</code>状态。</p>
<p>对于<code>M</code>和<code>E</code>状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而<code>S</code>状态可能是非一致的，如果一个缓存将处于<code>S</code>状态的缓存行作废了，而另一个缓存实际上可能已经</p>
<p>独享了该缓存行，但是该缓存却不会将该缓存行升迁为<code>E</code>状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的<code>copy</code>的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<p>从上面的意义看来E状态是一种投机性的优化：如果一个<code>CPU</code>想修改一个处于<code>S</code>状态的缓存行，总线事务需要将所有该缓存行的<code>copy</code>变成<code>Invalid</code>状态，而修改<code>E</code>状态的缓存不需要使用总线事务。</p>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>所谓的伪共享即指，在一个缓存行（缓存一致性协议针对的最小存取单元）内除了目标数据外可能还有其他的数据。如果多个核需要操纵这个缓存行内不同的数据就会使得效率变慢。</p>
<p>例如下图，变量x和变量y处于同一缓存行时，core1操作变量x，core2操作变量y。</p>
<p>流程即为：</p>
<ul>
<li><p>core1修改x后，按照一致性协议core2中的缓存行需要置为invalid，在core2需要的时候，core1将数据写回主存并通知core2重新读取</p>
</li>
<li><p>同理，core2修改y后，也要通知core1重新从主存读取。</p>
<p>就是在多核多线程并发场景下，多核需要操作不同变量位于同一个缓存行内的时候，会使得效率大打折扣。即为伪共享问题。</p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/false_sharing.jpg" alt></p>
</li>
</ul>
<h3 id="常见解决方法"><a href="#常见解决方法" class="headerlink" title="常见解决方法"></a>常见解决方法</h3><h4 id="1-空间换时间（cache-line-padding）"><a href="#1-空间换时间（cache-line-padding）" class="headerlink" title="1.空间换时间（cache line padding）"></a>1.空间换时间（cache line padding）</h4><p>缓存行对齐（填充），即是当所需数据不足64字节时，用无意义的字节填满剩下的缓存行空间。</p>
<p>比如<strong>Disruptor</strong></p>
<p>disruptor是一个性能极强的开源<strong>无锁并发</strong>框架，基于Disruptor的LMAX架构交易平台，号称单线程内每秒可处理600万笔订单。</p>
<p>disruptor框架的核心是Ringbuffer环形缓冲。<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">github源码</a>，<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网</a>也有文章介绍该框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">// cache line padding</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> cursor = INITIAL_CURSOR_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> p8, p9, p10, p11, p12, p13, p14; <span class="comment">// cache line padding</span></span><br></pre></td></tr></table></figure>

<p>上述即为核心解决方案，long类型占用8个字节，在目标变量的前后定义多个无意义的变量进行填充，以空间换取时间。</p>
<p>以下进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_CacheLinePadding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//320-370~</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_CacheLinePadding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">8</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//220 - 250</span></span><br></pre></td></tr></table></figure>

<h4 id="2-JDK8中的注解-Contended"><a href="#2-JDK8中的注解-Contended" class="headerlink" title="2.JDK8中的注解@Contended"></a>2.JDK8中的注解@Contended</h4><p>JDK7中，大多采用long padding的方式提高效率，即缓存行对齐。但是不同的CPU所对应的缓存行大小可能不一致，因此在8中采用了此注解，针对不同的底层自动优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_CacheLinePadding</span> </span>&#123;</span><br><span class="line"><span class="meta">@Contended</span><span class="comment">//需要加上VM option：-XX：-RestrictContended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T05_CacheLinePadding t05 = <span class="keyword">new</span> T05_CacheLinePadding();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</span><br><span class="line">            t05.x = i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</span><br><span class="line">                t05.y = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println((end - start)/<span class="number">100_0000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加注解前平均1750</span></span><br><span class="line"><span class="comment">//加注解后平均580</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@Contended</span>注解的作用范围</span></span><br><span class="line"><span class="comment">//允许反射使用</span></span><br><span class="line"><span class="comment"><span class="doctag">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//作用范围：成员变量；类、接口（包括注解类型）后者是枚举类 </span></span><br><span class="line"><span class="comment"><span class="doctag">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计组</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>1）最自然智慧的算法</p>
<p>2）用一种局部最功利的标准，总是做出在当前看来是最好的选择</p>
<p>3）难点在于证明局部最功利的标准可以得到全局最优解</p>
<p>4）对于贪心算法的学习主要以增加阅历和经验为主</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1从头到尾讲一道利用贪心算法求解的题目，包含证明"><a href="#1从头到尾讲一道利用贪心算法求解的题目，包含证明" class="headerlink" title="1从头到尾讲一道利用贪心算法求解的题目，包含证明"></a>1从头到尾讲一道利用贪心算法求解的题目，包含证明</h3><p>给定一个由字符串组成的数组strs，</p>
<p>必须把所有的字符串拼接起来，</p>
<p>返回所有可能的<strong>拼接</strong>结果中，字典序最小的结果</p>
<p><code>（字典序：将字符串放入字典比较大小，在前小，compareTo方法就是比较的字典序，字符串长度不同的时候，短的补0,0认为比a的ascii码还要小）</code></p>
<p><code>证明所定的排序策略的传递性</code></p>
<p><img src="/2020/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/C:%5CUsers%5C%E5%88%98%E5%89%91%E7%BF%94%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621095555255.png" alt=" "></p>
<h3 id="贪心算法求解的标准流程"><a href="#贪心算法求解的标准流程" class="headerlink" title="贪心算法求解的标准流程"></a>贪心算法求解的标准流程</h3><p>1，分析业务</p>
<p>2，根据业务逻辑找到不同的贪心策略</p>
<p>3，对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性</p>
<p>这往往是特别困难的，要求数学能力很高且不具有统一的技巧性</p>
<h3 id="贪心算法的解题套路"><a href="#贪心算法的解题套路" class="headerlink" title="贪心算法的解题套路"></a>贪心算法的解题套路</h3><p>1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试</p>
<p>2，脑补出贪心策略A、贪心策略B、贪心策略C…</p>
<p>3，用解法X和对数器，用实验的方式得知哪个贪心策略正确</p>
<p>4，不要去纠结贪心策略的证明</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础</title>
    <url>/2020/06/04/MySql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>like子句可以在where子句中使用，用来匹配某个字段。提供了四种匹配符：</p>
<ul>
<li><p><code>%</code> :表示0个或多个字符。可以匹配任意类型和长度的字符。如果是中文使用%%。</p>
</li>
<li><p><code>_</code>:表示单个任意字符。常用来限制匹配的数量。</p>
</li>
<li><p><code>[]</code>:表示括号内所列字符的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</p>
</li>
<li><p><code>[^]</code>:表示不在括号所在列之内的单个字符。上述的特殊字符如果无法实现可以用[]括起来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> teacher <span class="keyword">where</span> tname <span class="keyword">like</span> <span class="string">'李%'</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
</search>
