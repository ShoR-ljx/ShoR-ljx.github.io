<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【javaSE】关键字</title>
    <url>/2020/05/26/%E3%80%90javaSE%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Java关键字是预先定义好的，有特殊意义的标识符。在Java语言中关键字一律小写。关键字不可以用作变量名、方法名、类名、包名和参数类型。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>assert</td>
<td>断言</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>break</td>
<td>用于在循环语句中跳出当前循环或配合label使用</td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>continue</td>
<td>跳过<strong>本次</strong>循环执行，到下一次循环开始处</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中，必执行一次循环体</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型，浮点数默认类型</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>enum</td>
<td>定义枚举类</td>
</tr>
<tr>
<td>extends</td>
<td>继承，可以继承类或者抽象类，不能继承接口，继承抽象类的抽象方法也必须重写，但是抽象类里面的未声明abstract的方法可不重写</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
</tr>
<tr>
<td>finally</td>
<td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型，使用的时候数字后面跟f或F</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>implements</td>
<td>实现，Java多实现</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据，也可用在循环中，但是就直接跳出该方法了</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>strictfp</td>
<td>strict float point 精确浮点</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>synchronized</td>
<td>同步</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常，方法体内</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前成员方法中所有需要抛出的异常，在方法声明处，异常用,隔开</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>const</td>
<td>用于修改字段或局部变量的声明。它指定字段或局部变量的值是常数，不能被修改</td>
</tr>
<tr>
<td>goto</td>
<td>指定跳转到标签，找到标签后，程序将处理从下一行开始的命令</td>
</tr>
<tr>
<td>true</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>static主要有四种使用场景</strong></p>
<ul>
<li><p><strong>修饰成员变量和成员方法：</strong>被static修饰的成员变量或方法属于当前的类，而非某个特定的实例对象，被类的所有对象共享。可以通过类名调用，成员变量属于静态成员变量，存放在Java内存区域中的方法区。</p>
</li>
<li><p><strong>静态代码块：</strong>静态代码块定义在类中的方法外，静态代码块在非静态代码块之前执行（静态代码块-&gt;非静态代码块-&gt;构造方法）。静态代码块只会执行一次，不论该类创造了多少对象。</p>
</li>
<li><p><strong>静态内部类（static可以修饰类，但是只能修饰内部类）：</strong>静态内部类与非静态内部类之间存在一个最大的区别是：非静态内部类在编译完成之后会隐式地保存着一个引用，该引用指向创建它的外部类，但是静态内部类是在外部类加载的时候也加载的，并没有这个隐含地引用。没有这个引用也就意味着：1.它的创建是不需要依赖外部类的创建。2.它不能使用外部类得到非static成员变量和成员方法。因为静态嘛，静态无法使用非静态的东西。</p>
</li>
<li><p><strong>静态导包（用来导入类中的静态资源，1.5之后的新特性）：</strong>格式为import static …</p>
<p> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中的静态成员，可以直接使用类中的静态成员变量和成员方法。也就是说本来在该类中可以通过</p>
<p>类名.静态方法() 类名.静态变量  的方式来调用，现在不需要加上类名.这个前缀了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_01</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">static_01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"非静态代码块，也称构造代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"共有的静态方法"</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"静态方法中的非静态代码块"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"main方法体"</span>);</span><br><span class="line">		 &#123;</span><br><span class="line">			 System.out.println(<span class="string">"main方法非静态代码块"</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 static_01 o1 = <span class="keyword">new</span> static_01();</span><br><span class="line">		 o1.method01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_02</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		static_01 o2 = <span class="keyword">new</span> static_01();</span><br><span class="line">		static_01 o3 = <span class="keyword">new</span> static_01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行该类main方法结果为：</span><br><span class="line"></span><br><span class="line">静态代码块</span><br><span class="line">main方法体</span><br><span class="line">main方法非静态代码块</span><br><span class="line">非静态代码块，也称构造代码块</span><br><span class="line">构造方法</span><br><span class="line">共有的静态方法</span><br><span class="line">静态方法中的非静态代码块</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">可以看到静态代码块是首先执行的，而非静态代码块是在创建对象的时候才执行，而如果静态代码块已经执行过就不会再执行了，而非静态代码块在每创建一个对象的时候都会执行。</span><br></pre></td></tr></table></figure>

<p>非静态代码块与构造函数的区别是：非静态代码块是给所有对象进行统一的初始化，而构造函数是给对应的对象初始化，因构造函数是可以多个的，运行什么样的构造函数创建什么样的对象，但是无论创建哪个对象都会执行相同的构造代码块。共性和个性的区别。</p>
<p><strong>补充：</strong></p>
<p>关于Class.forName方法加载类</p>
<p>查看API可知，调用Class.forName(“package.className”)的方式实际上是等价于调用Class.forName(className, true, currentLoader)  (ClassLoader.getSystemClassLoader())</p>
<p>因此在加载类的时候就做了类的初始化操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;static_01&gt; clazz = static_01<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//只是单纯的加载类，不会初始化，即没有使用数据</span></span><br><span class="line">            static_01 static_01 = static_01<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;<span class="comment">//静态代码块-非静态代码块-构造方法</span></span><br><span class="line"><span class="comment">//            static_01 s1 = new static_01();</span></span><br><span class="line"><span class="comment">//            static_01 s2 = new static_01();</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"shu.keyWords.static_01"</span>,<span class="keyword">false</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码取消初始化操作之后就不会执行静态代码块，只是将类加载成字节码文件。</p>
<p>其中new是强类型，相对高效，能调用任何public构造方法。newInstance是弱类型，相对低效，只能调用无参构造。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li><p><strong>final修饰变量，则等同于常量</strong></p>
</li>
<li><p><strong>final修饰方法中的参数，称为最终参数。</strong></p>
</li>
<li><p><strong>final修饰类，则类不能被继承</strong></p>
</li>
<li><p><strong>final修饰方法，则方法不能被重写。</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
</search>
