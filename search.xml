<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL调优01</title>
    <url>/2020/06/02/MySQL%E8%B0%83%E4%BC%9801/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>show profiles  查看历史信息</p>
<p>show profile 查看最近一条操作</p>
<p>MySQL performance schema  性能监控  用来替代show profile</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaSE】权限修饰符</title>
    <url>/2020/05/30/%E3%80%90JavaSE%E3%80%91%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>Java的访问权限修饰符总共有4中，依照权限大小的顺序依次为：</p>
<ol>
<li>public</li>
<li>protected</li>
<li>friendly(default)</li>
<li>private</li>
</ol>
<p>具体权限表示可以通过下面的表格来详细描述：</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>本类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>同包其他类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>不同包其他类</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
<tr>
<td>同包子类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>不同包子类</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody></table>
<p>可以看到private用有最低的权限，该修饰符下的类、属性或是方法只能由本类使用，其他类无法访问。</p>
<p>default权限属于包权限，该包下的所有类均可以访问，但其他包的任何类都无权访问。</p>
<p>protected属于子类权限，同包下的任何类可以访问，不同包下的类如果是该类的子类仍然可以访问该权限修饰符修饰的类、属性或是方法。</p>
<p>public拥有最高权限，任何类都可以访问。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【javaSE】关键字</title>
    <url>/2020/05/26/%E3%80%90javaSE%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Java关键字是预先定义好的，有特殊意义的标识符。在Java语言中关键字一律小写。关键字不可以用作变量名、方法名、类名、包名和参数类型。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>assert</td>
<td>断言</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>break</td>
<td>用于在循环语句中跳出当前循环或配合label使用</td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>continue</td>
<td>跳过<strong>本次</strong>循环执行，到下一次循环开始处</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中，必执行一次循环体</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型，浮点数默认类型</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>enum</td>
<td>定义枚举类</td>
</tr>
<tr>
<td>extends</td>
<td>继承，可以继承类或者抽象类，不能继承接口，继承抽象类的抽象方法也必须重写，但是抽象类里面的未声明abstract的方法可不重写</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
</tr>
<tr>
<td>finally</td>
<td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型，使用的时候数字后面跟f或F</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>implements</td>
<td>实现，Java多实现</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据，也可用在循环中，但是就直接跳出该方法了</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>strictfp</td>
<td>strict float point 精确浮点</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>synchronized</td>
<td>同步</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常，方法体内</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前成员方法中所有需要抛出的异常，在方法声明处，异常用,隔开</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>const</td>
<td>用于修改字段或局部变量的声明。它指定字段或局部变量的值是常数，不能被修改</td>
</tr>
<tr>
<td>goto</td>
<td>指定跳转到标签，找到标签后，程序将处理从下一行开始的命令</td>
</tr>
<tr>
<td>true</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>static主要有四种使用场景</strong></p>
<ul>
<li><p><strong>修饰成员变量和成员方法：</strong>被static修饰的成员变量或方法属于当前的类，而非某个特定的实例对象，被类的所有对象共享。可以通过类名调用，成员变量属于静态成员变量，存放在Java内存区域中的方法区。</p>
</li>
<li><p><strong>静态代码块：</strong>静态代码块定义在类中的方法外，静态代码块在非静态代码块之前执行（静态代码块-&gt;非静态代码块-&gt;构造方法）。静态代码块只会执行一次，不论该类创造了多少对象。</p>
</li>
<li><p><strong>静态内部类（static可以修饰类，但是只能修饰内部类）：</strong>静态内部类与非静态内部类之间存在一个最大的区别是：非静态内部类在编译完成之后会隐式地保存着一个引用，<strong>该引用指向创建它的外部类</strong>，但是静态内部类是在外部类加载的时候也加载的，并没有这个隐含地引用。没有这个引用也就意味着：1.它的创建是不需要依赖外部类的创建。2.它不能使用外部类得到非static成员变量和成员方法。因为静态嘛，静态无法使用非静态的东西。</p>
</li>
<li><p><strong>静态导包（用来导入类中的静态资源，1.5之后的新特性）：</strong>格式为import static …</p>
<p> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中的静态成员，可以直接使用类中的静态成员变量和成员方法。也就是说本来在该类中可以通过</p>
<p>类名.静态方法() 类名.静态变量  的方式来调用，现在不需要加上类名.这个前缀了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_01</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">static_01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"非静态代码块，也称构造代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"共有的静态方法"</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"静态方法中的非静态代码块"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"main方法体"</span>);</span><br><span class="line">		 &#123;</span><br><span class="line">			 System.out.println(<span class="string">"main方法非静态代码块"</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 static_01 o1 = <span class="keyword">new</span> static_01();</span><br><span class="line">		 o1.method01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_02</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		static_01 o2 = <span class="keyword">new</span> static_01();</span><br><span class="line">		static_01 o3 = <span class="keyword">new</span> static_01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行该类main方法结果为：</span><br><span class="line"></span><br><span class="line">静态代码块</span><br><span class="line">main方法体</span><br><span class="line">main方法非静态代码块</span><br><span class="line">非静态代码块，也称构造代码块</span><br><span class="line">构造方法</span><br><span class="line">共有的静态方法</span><br><span class="line">静态方法中的非静态代码块</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">可以看到静态代码块是首先执行的，而非静态代码块是在创建对象的时候才执行，而如果静态代码块已经执行过就不会再执行了，而非静态代码块在每创建一个对象的时候都会执行。</span><br></pre></td></tr></table></figure>

<p>非静态代码块与构造函数的区别是：非静态代码块是给所有对象进行统一的初始化，而构造函数是给对应的对象初始化，因构造函数是可以多个的，运行什么样的构造函数创建什么样的对象，但是无论创建哪个对象都会执行相同的构造代码块。共性和个性的区别。</p>
<p><strong>补充：</strong></p>
<p>关于Class.forName方法加载类</p>
<p>查看API可知，调用Class.forName(“package.className”)的方式实际上是等价于调用Class.forName(className, true, currentLoader)  (ClassLoader.getSystemClassLoader())</p>
<p>因此在加载类的时候就做了类的初始化操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;static_01&gt; clazz = static_01<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//只是单纯的加载类，不会初始化，即没有使用数据</span></span><br><span class="line">            static_01 static_01 = static_01<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;<span class="comment">//静态代码块-非静态代码块-构造方法</span></span><br><span class="line"><span class="comment">//            static_01 s1 = new static_01();</span></span><br><span class="line"><span class="comment">//            static_01 s2 = new static_01();</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"shu.keyWords.static_01"</span>,<span class="keyword">false</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码取消初始化操作之后就不会执行静态代码块，只是将类加载成字节码文件。</p>
<p>其中new是强类型，相对高效，能调用任何public构造方法。newInstance是弱类型，相对低效，只能调用无参构造。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li><p><strong>final修饰变量，则等同于常量</strong>.</p>
<p>​        final修饰变量是使用最多的地方。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能指向另一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Person person;</span><br><span class="line">    <span class="comment">//如果同时加了static 和 final 就必须立刻赋初始值，因为static在构造方法之前加载的</span></span><br><span class="line"><span class="comment">//只加其中一个修饰关键字是都可以在构造方法赋值的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">        person.setAge(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//    public FinalTest01() &#123;</span></span><br><span class="line"><span class="comment">//        super();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//这个时候会报错，也就是说所有的构造方法都必须对这个final成员变量赋值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalTest finalTest = <span class="keyword">new</span> FinalTest(<span class="keyword">new</span> Person());</span><br><span class="line">        System.out.println(finalTest.person.getAge());<span class="comment">//11</span></span><br><span class="line">        finalTest.person.setAge(<span class="number">13</span>);</span><br><span class="line">        System.out.println(finalTest.person.getAge());<span class="comment">//13</span></span><br><span class="line">        <span class="comment">//final成员变量必须让所有的构造方法赋初始值，且引用类型变量地址值不可变，变量的内部属性可以通过自己的方法来改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">    在某偏博客还是帖子看到的例子：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = <span class="string">"hello"</span>;</span><br><span class="line">        String d = <span class="string">"hello"</span>;</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        String e = d + <span class="number">2</span>;</span><br><span class="line">        System.out.println((a == c));</span><br><span class="line">        System.out.println((a == e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出结果：true、false</span></span><br><span class="line"><span class="comment">     大家可以先想一下这道题的输出结果。为什么第一个比较结果为true，而第二个比较结果为fasle。这里面就是final变量和普通变量的区别了，当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。因此在上面的一段代码中，由于变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b 替换为它的值。而对于变量d的访问却需要在运行时通过链接来进行。想必其中的区别大家应该明白了，不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化，比如下面的这段代码就不会进行优化：    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = getHello();</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        System.out.println((a == c));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码的输出结果为false。这里要注意一点就是：不要以为某些数据是final就可以在编译期知道其值，通过变量b我们就知道了，在这里是使用getHello()方法对其进行初始化，他要在运行期才能知道其值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final修饰方法参数列表中的参数，称为最终参数。</strong></p>
</li>
<li><p><strong>final修饰类，则类不能被继承</strong>。final类中的所有成员方法都会被隐式地指定为final方法。</p>
</li>
<li><p><strong>final修饰方法，则方法不能被重写。</strong></p>
<p>​        使用final修饰方法的原因有两个，1是将方法锁定，以防止任何继承类修改它的含义；2是因为效率，在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能会看不到内嵌调用带来的性能提升。现在的版本已经不需要使用final来进行这样的优化了，类中所有的private方法都会隐式地指定为final。</p>
<p>　    因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即<strong>父类的final方法是不能被子类所覆盖的</strong>，也就是说子类是不能够存在和父类一模一样的方法的。</p>
<pre><code>final修饰的方法表示此方法已经是“**最后的、最终的**”含义，亦即**此方法不能被重写**（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</code></pre></li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this关键字用于引用当前类的<strong>实例</strong>。</p>
<p>所以要注意哪些地方才可以使用this关键字。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super关键字用于从子类访问父类的变量和方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/05/30/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>值传递：</p>
<p>​    java参数传递采用的是值传递，对于<strong>基本类型的变量</strong>，相当于直接将变量进行了拷贝，在方法内部改变了变量i的值也不会影响方法外的i。</p>
<p>​    对于引用变量，传递的是引用的值，也就是说让实参和形参同时指向了同一个对象，因此让形参重新指向另一个对象对实参并没有任何影响。</p>
<p>简单定义：定义在一个类内部的类就叫内部类。</p>
<p>内部类也是一个很困惑的点了。</p>
<p>首先是分类，内部类可以按照所在区域的不同分为以下四种：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态内部类</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>参考：<a href="https://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenssy/p/3388487.html</a></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h2 id="内部类详解"><a href="#内部类详解" class="headerlink" title="内部类详解"></a>内部类详解</h2><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】next导航栏404</title>
    <url>/2020/05/27/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404/</url>
    <content><![CDATA[<p>去查看了public下的index.html代码，发现所有导航路径后都有%20，%20代表空格，而这个一部分又是next主题中生成的，去查看了配置文件，将配置文件里 ||之前所有的空格删掉。</p>
<p><img src="/2020/05/27/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404%5Cpic1.jpg" alt></p>
<p>然后重新生成静态文件并部署即可。</p>
<p>侧边栏的链接可能也有404的问题，直接去主题目录下找相应名称的配置文件进行修改即可。</p>
<p>如果没有标签和分类页面，可以通过 hexo new page tags这样的命令在source下创建文件夹，并修改index.md<br>如下，冒号后面有空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome插件</title>
    <url>/2020/06/02/chrome%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="插件的离线下载方式"><a href="#插件的离线下载方式" class="headerlink" title="插件的离线下载方式"></a>插件的离线下载方式</h2><ol>
<li><p>去应用商店自行下载</p>
</li>
<li><p>离线安装</p>
<p>下载需要安装 Chrome 扩展的 CRX 文件，并将其后缀名改为 ZIP 格式。然后解压缩这个 Chrome 扩展包文件。</p>
<p>点击你的 Chrome 浏览器中的「更多工具 &gt; 扩展程序」菜单或者直接在地址栏输入: chrome://extensions/ 打开扩展程序管理页面。</p>
<p>在打开的扩展程序管理页面上，选择开发者模式，点击 「加载已解压的扩展程序」。</p>
<p>选择前面解压缩的安装包所在的目录并确认后就完成了该插件的安装。</p>
</li>
</ol>
<h2 id="插件下载地址"><a href="#插件下载地址" class="headerlink" title="插件下载地址"></a>插件下载地址</h2><ul>
<li><p><strong>Crx4Chrome</strong></p>
<p>链接：<a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">https://www.crx4chrome.com/</a></p>
<p>包含了一些扩展排行，可以帮助探索新颖的好用的工具。</p>
</li>
</ul>
<ul>
<li><p><strong>扩展迷</strong></p>
<p>链接：<a href="https://extfans.com/" target="_blank" rel="noopener">https://extfans.com/</a></p>
<p>提供 Chrome 商店中优秀的 Chrome 插件推荐与下载服务。</p>
</li>
</ul>
<ul>
<li><p><strong>chrome插件网</strong></p>
<p>链接：<a href="http://chromecj.com/" target="_blank" rel="noopener">http://chromecj.com/</a></p>
<p>Chrome 插件网致力于帮助用户找到、安装、学会使用优秀的 Chrome 插件来提高谷歌浏览器的使用体验。</p>
</li>
</ul>
<h2 id="GitZip-for-Github"><a href="#GitZip-for-Github" class="headerlink" title="GitZip for Github"></a>GitZip for Github</h2><p>一个方便用户下载github资源的Chrome插件，有时候只是想要github某个仓库的部分文件而不是下载整个仓库，但原生的git命令不支持，所以在网上搜索可行的方法。</p>
<p>GitZip的使用很简单，在需要下载的仓库的某个文件或文件夹前面的空白处双击就会出现一个勾，可以选择多个文件或文件夹，这时候页面会弹出下载的按键，选择好之后点击下载即可，下载速度感觉比clone要快0.0</p>
<p>如果你觉得安装插件比较麻烦的话，也同样可以直接使用  GitZip for Github 的 Web 版本。方法类似，这里就不再赘述了。</p>
<p>Web 版本地址：<a href="https://kinolien.github.io/gitzip/" target="_blank" rel="noopener">https://kinolien.github.io/gitzip/</a></p>
<p>除了这个之外，也还有许多其他的方式来满足下载单项资源。</p>
<ul>
<li><p><a href="http://zhoudaxiaa.gitee.io/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
</li>
<li><p><a href="https://www.runoob.com/svn/tortoisesvn-intro.html" target="_blank" rel="noopener">TotoiseSVN</a></p>
</li>
<li><p><a href="https://github.com/hua1995116/git-down-repo" target="_blank" rel="noopener">git-down-repo</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install git-down-repo -g <span class="comment">// 安装全局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat  // 下载整个仓库（默认master）</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat dev // 下载某个仓库的dev分支</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/tree/master/config // 下载仓库某个文件夹</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/blob/master/config/dev.env.js // 下载某个文件</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/blob/master/config/dev.env.js https://github.com/hua1995116/webpack-plugin-inner-script/blob/master/index.js // 下载多个项目（空格分隔）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>参考：</strong><a href="https://blog.csdn.net/weixin_44058333/article/details/97138348" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44058333/article/details/97138348</a></p>
<p>​            <a href="https://cloud.tencent.com/developer/article/1463081" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1463081</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>冲浪小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>底层基础知识</title>
    <url>/2020/06/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>计算机需要解决的最根本问题其实是：如何代表数字</p>
<h2 id="汇编语言（机器语言）的执行过程"><a href="#汇编语言（机器语言）的执行过程" class="headerlink" title="汇编语言（机器语言）的执行过程"></a>汇编语言（机器语言）的执行过程</h2><p>汇编语言的本质是机器语言的助记符，其实就是机器语言。</p>
<p>使用一些便于人理解的符号来表示一些操作，比如add sub等。</p>
<p>执行流程：</p>
<p>​        计算机通电-&gt; CPU读取内存中的程序（电信号输入） -&gt; <strong>时钟发生器</strong>不断的震荡通断电 -&gt; 推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期） -&gt; 计算完成 -&gt; 写回（电信号）   -&gt; 写给显卡输出</p>
<h2 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h2><p>PC ： Program Counter 程序计数器（记录当前指令地址）</p>
<p>​        记录当前指令占位多少，来推断下一指令的位置。</p>
<p>Register（寄存器） ： 暂时储存CPU计算需要用到的数据</p>
<p>ALU ： Arithmetic &amp; Logic Unit 运算和逻辑单元</p>
<p>CU ： Control Unit 控制单元</p>
<p>MMU ： Memory Management Unit 内存管理单元</p>
<p>Cache : L1 L2 L3(多核共享)</p>
<h2 id="CPU的制作与原理"><a href="#CPU的制作与原理" class="headerlink" title="CPU的制作与原理"></a>CPU的制作与原理</h2><p><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="noopener">https://www.sohu.com/a/255397866_468626</a></p>
<p><a href="https://www.bilibili.com/video/av47388949?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av47388949?p=2</a></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-CPU缓存层次"><a href="#1-CPU缓存层次" class="headerlink" title="1.CPU缓存层次"></a>1.CPU缓存层次</h3><p>现代CPU的储存结构如下图所示。</p>
<p><img src="/2020/06/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5CCPU_cache.jpg" alt></p>
<p>SRAM: Static Random-Access Memory 静态随机存取器。静态是指只要保持通电状态，其内储存的数据就能恒常保持。</p>
<p>DRAM： Dynamic Random Access Memory动态随机存取储存器。动态指其内的数据需要周期性的更新，否则会导致数据出错。</p>
<p>为了缓和CPU运算速度远快于从内存读取数据的速度的矛盾，引入了缓存。</p>
<ul>
<li>L1高速缓存：也叫一级缓存。一般内置在内核旁边，是与CPU结合最为紧密的CPU缓存。一次访问只需要2~4个时钟周期</li>
<li>L2高速缓存：也叫二级缓存。空间比L1缓存大，速度比L1缓存略慢。一次访问约需要10多个时钟周期</li>
<li>L3高速缓存：也叫三级缓存。部分单CPU多核心的才会有的缓存，介于多核和内存之间。存储空间已达Mb级别，一次访问约需要数十个时钟周期</li>
</ul>
<p>对于多核处理器，L3是每个CPU内共享的，L1 L2 及寄存器是每个核独有的。</p>
<h3 id="总线锁及缓存锁"><a href="#总线锁及缓存锁" class="headerlink" title="总线锁及缓存锁"></a>总线锁及缓存锁</h3><p>总线锁：锁住总线。通过处理器发出lock指令，总线接收到指令后，其他处理器的请求就会被阻塞，直到此处理器执行完成。这样处理器可以独占共享内存，但因此其他的处理器就只能阻塞等待，无法发挥多处理的优势。</p>
<p>缓存锁：锁定被缓存的共享对象。接收到lock指令，通过缓存一致性协议，维护本处理器内部缓存和其他处理器缓存的一致性。</p>
<h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>虽然每次CPU需要使用的数据可能只有一小块，但是因为程序运行的局部性原理，提出了缓存行的概念。即一次读取一块内存数据放入缓存，即为缓存行。缓存行（cache line）是CPU缓存中可分配、操作的最小存储单元，与CPU的架构相关，通常有32字节、64字节、128字节等。经过大量实验取折中值为64字节。</p>
<ul>
<li>缓存行越大，局部性空间效率越高，但读取的时间就慢</li>
<li>缓存行越小，局部性空间效率越低，但读取的时间就快</li>
</ul>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>每个CPU都有自己的高速缓存，但又共享同一个主存。当多个处理器都涉及同一块主存区域的更改时，将导致各自的缓存数据不一致。因此提出缓存一致性协议来保证各处理器读取数据的一致性。</p>
<p>每个CPU厂商可能都有自己的缓存一致性协议。例如Intel的MESI协议。其他还有MSI、MOSI、MESIF、Synapse Firefly Dragon等。</p>
<p>MESI(Modified Exclusive Shared Or Invalid)</p>
<p><strong>MESI的状态</strong></p>
<p>CPU中的每个cache line使用4种状态标记（使用额外的两位(bit)来表示）：</p>
<p><strong>M：被修改（Modified）</strong></p>
<p>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，即与主存中的数据不一致，该缓存行中的内存需要在未来某个时间点写回主存。</p>
<p><strong>E：独享的(Exclusive)</strong></p>
<p>该缓存行<strong>只被缓存在该CPU的缓存</strong>中，<strong>它是未被修改过的，与主存中的数据一致</strong>。该状态可在任何时刻当有其他CPU读取该内存时变成共享状态（shared）。</p>
<p><strong>S：共享的（shared）</strong></p>
<p>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致，当有一个CPU修改该缓存行中的数据时，其他CPU中该缓存行可以被作废，变为Invalid状态。</p>
<p><strong>I：无效的（Invalid）</strong></p>
<p>该缓存是无效的（可能有其他CPU修改了该缓存行）</p>
<p>状态转换图及流程表</p>
<p><img src="/2020/06/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5CMESI_pic.jpg" alt></p>
<p><img src="/2020/06/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5Cmesi_chart.png" alt></p>
<p>在一个典型系统中，可能会有几个缓存（在多核系统中，每个核心都会有自己的缓存）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了减少<code>CPU</code>读写共享主存的次数。</p>
<p>一个缓存除在<code>Invalid</code>状态外都可以满足cpu的读请求，一个<code>Invalid</code>的缓存行必须从主存中读取（变成<code>S</code>或者 <code>E</code>状态）来满足该<code>CPU</code>的读请求。</p>
<p>一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于<code>S</code>状态，必须先将其它缓存中该缓存行变成<code>Invalid</code>状态（也既是不允许不同<code>CPU</code>同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：<code>RequestFor Ownership</code> (<code>RFO</code>)。</p>
<p>缓存可以随时将一个非M状态的缓存行作废，或者变成<code>Invalid</code>状态，而一个<code>M</code>状态的缓存行必须先被写回主存。</p>
<p>一个处于<code>M</code>状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。</p>
<p>一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（<code>Invalid</code>）。</p>
<p>一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成<code>S</code>状态。</p>
<p>对于<code>M</code>和<code>E</code>状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而<code>S</code>状态可能是非一致的，如果一个缓存将处于<code>S</code>状态的缓存行作废了，而另一个缓存实际上可能已经</p>
<p>独享了该缓存行，但是该缓存却不会将该缓存行升迁为<code>E</code>状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的<code>copy</code>的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<p>从上面的意义看来E状态是一种投机性的优化：如果一个<code>CPU</code>想修改一个处于<code>S</code>状态的缓存行，总线事务需要将所有该缓存行的<code>copy</code>变成<code>Invalid</code>状态，而修改<code>E</code>状态的缓存不需要使用总线事务。</p>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>所谓的伪共享即指，在一个缓存行（缓存一致性协议针对的最小存取单元）内除了目标数据外可能还有其他的数据。如果多个核需要操纵这个缓存行内不同的数据就会使得效率变慢。</p>
<p>例如下图，变量x和变量y处于同一缓存行时，core1操作变量x，core2操作变量y。</p>
<p>流程即为：</p>
<ul>
<li><p>core1修改x后，按照一致性协议core2中的缓存行需要置为invalid，在core2需要的时候，core1将数据写回主存并通知core2重新读取</p>
</li>
<li><p>同理，core2修改y后，也要通知core1重新从主存读取。</p>
<p>就是在多核多线程并发场景下，多核需要操作不同变量位于同一个缓存行内的时候，会使得效率大打折扣。即为伪共享问题。</p>
<p><img src="/2020/06/02/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5Cfalse_sharing.jpg" alt="底层基础知识\false_sharing.jpg"></p>
</li>
</ul>
<h3 id="常见解决方法"><a href="#常见解决方法" class="headerlink" title="常见解决方法"></a>常见解决方法</h3><h4 id="1-空间换时间（cache-line-padding）"><a href="#1-空间换时间（cache-line-padding）" class="headerlink" title="1.空间换时间（cache line padding）"></a>1.空间换时间（cache line padding）</h4><p>缓存行对齐（填充），即是当所需数据不足64字节时，用无意义的字节填满剩下的缓存行空间。</p>
<p>比如<strong>Disruptor</strong></p>
<p>disruptor是一个性能极强的开源<strong>无锁并发</strong>框架，基于Disruptor的LMAX架构交易平台，号称单线程内每秒可处理600万笔订单。</p>
<p>disruptor框架的核心是Ringbuffer环形缓冲。<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">github源码</a>，<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网</a>也有文章介绍该框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">// cache line padding</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> cursor = INITIAL_CURSOR_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> p8, p9, p10, p11, p12, p13, p14; <span class="comment">// cache line padding</span></span><br></pre></td></tr></table></figure>

<p>上述即为核心解决方案，long类型占用8个字节，在目标变量的前后定义多个无意义的变量进行填充，以空间换取时间。</p>
<p>以下进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_CacheLinePadding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//320-370~</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_CacheLinePadding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">8</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//220 - 250</span></span><br></pre></td></tr></table></figure>

<h4 id="2-JDK8中的注解-Contended"><a href="#2-JDK8中的注解-Contended" class="headerlink" title="2.JDK8中的注解@Contended"></a>2.JDK8中的注解@Contended</h4><p>JDK7中，大多采用long padding的方式提高效率，即缓存行对齐。但是不同的CPU所对应的缓存行大小可能不一致，因此在8中采用了此注解，针对不同的底层自动优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_CacheLinePadding</span> </span>&#123;</span><br><span class="line"><span class="meta">@Contended</span><span class="comment">//需要加上VM option：-XX：-RestrictContended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T05_CacheLinePadding t05 = <span class="keyword">new</span> T05_CacheLinePadding();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</span><br><span class="line">            t05.x = i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</span><br><span class="line">                t05.y = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println((end - start)/<span class="number">100_0000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加注解前平均1750</span></span><br><span class="line"><span class="comment">//加注解后平均580</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@Contended</span>注解的作用范围</span></span><br><span class="line"><span class="comment">//允许反射使用</span></span><br><span class="line"><span class="comment"><span class="doctag">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//作用范围：成员变量；类、接口（包括注解类型）后者是枚举类 </span></span><br><span class="line"><span class="comment"><span class="doctag">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
</search>
