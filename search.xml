<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JMM</title>
    <url>/2020/06/06/JMM/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优01</title>
    <url>/2020/06/02/MySQL%E8%B0%83%E4%BC%9801/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>show profiles  查看历史信息</p>
<p>show profile 查看最近一条操作</p>
<p>MySQL performance schema  性能监控  用来替代show profile</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA_plugins搜索不到</title>
    <url>/2020/06/05/IDEA-plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0/</url>
    <content><![CDATA[<p>因为想下载jclasslib这个插件，但是在IDEA搜索显示不出来，在晚上找了下面的解决办法。</p>
<p><img src="/2020/06/05/IDEA-plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0/figure.png" alt></p>
<p><img src="/2020/06/05/IDEA-plugins%E6%90%9C%E7%B4%A2%E4%B8%8D%E5%88%B0/figure01.png" alt></p>
<p>然后就是我最后实现的这种方法，说是宽带上网运营商将IDEA下载插件的网站屏蔽了，所以开手机<strong>热点</strong>连上去就可以下载了。</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL中DQL、DML等概念及区别</title>
    <url>/2020/06/16/SQL%E4%B8%ADDQL%E3%80%81DML%E7%AD%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="SQL结构化查询语言包含6个部分"><a href="#SQL结构化查询语言包含6个部分" class="headerlink" title="SQL结构化查询语言包含6个部分"></a>SQL结构化查询语言包含6个部分</h2><p>1.数据查询语言（DQL: Data Query Language）数据检索语句，用于从表中获取数据。通常最常用的为保留字SELECT,并且常与FROM子句、WHERE子句组成查询SQL查询语句。语法：    SELECT &lt;字段名&gt; FROM &lt;表或视图名&gt; WHERE &lt;查询条件&gt;;</p>
<p>2.数据操纵语言（DML：Data Manipulation Language）主要用来对数据库的数据进行一些操作，常用的就是INSERT、UPDATE、DELETE。语法：    INSERT INTO &lt;表名&gt;(列1,列2,…) VALUES (值1,值2,…);    UPDATE &lt;表名&gt; SET &lt;列名&gt;=新值 WHERE &lt;列名&gt;=某值;    DELETE FROM &lt;表名&gt; WHERE &lt;列名&gt;=某值;</p>
<p>3.事务处理语言（DPL）事务处理语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。</p>
<p>4.数据控制语言（DCL）通过GRANT和REVOKE，确定单个用户或用户组对数据库对象的访问权限。</p>
<p>5.数据定义语言（DDL）常用的有CREATE和DROP，用于在数据库中创建新表或删除表，以及为表加入索引等。</p>
<p>6.指针控制语言（CCL）它的语句，想DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。注：   SQL是一个标准，每个数据库服务器都在标准的基础上进行了相应的调整和扩展，相应的，每个数据库对数据的各种操作语言的语法就会做出相应的调整。在MySQL中，SQL通常分为DDL、DML和查询，还包括一些其它语句类别。MySQL将SELECT与INSERT、UPDATE、DELETE分别划分到了查询和DML，但是也并非绝对的划分，通常会将SELECT与INSERT、UPDATE、DELETE一起划分为DML。具体参见MySQL官网中的MySQL Glossary.</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql基础</title>
    <url>/2020/06/04/MySql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>like子句可以在where子句中使用，用来匹配某个字段。提供了四种匹配符：</p>
<ul>
<li><p><code>%</code> :表示0个或多个字符。可以匹配任意类型和长度的字符。如果是中文使用%%。</p>
</li>
<li><p><code>_</code>:表示单个任意字符。常用来限制匹配的数量。</p>
</li>
<li><p><code>[]</code>:表示括号内所列字符的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</p>
</li>
<li><p><code>[^]</code>:表示不在括号所在列之内的单个字符。上述的特殊字符如果无法实现可以用[]括起来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> teacher <span class="keyword">where</span> tname <span class="keyword">like</span> <span class="string">'李%'</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLyog安装</title>
    <url>/2020/06/16/SQLyog%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="SQLyog12-0-9下载安装"><a href="#SQLyog12-0-9下载安装" class="headerlink" title="SQLyog12.0.9下载安装"></a>SQLyog12.0.9下载安装</h2><p>sqlyog百度云链接（永久有效）：<a href="http://pan.baidu.com/s/1i5j4GG9" target="_blank" rel="noopener">http://pan.baidu.com/s/1i5j4GG9</a> 密码：t906</p>
<p>下载后直接运行exe文件即可，为64位版本。</p>
<p>按照文档内容进行收费到免费的操作0.0</p>
<h2 id="与MySQL新建连接过程中报-2058-错误的解决"><a href="#与MySQL新建连接过程中报-2058-错误的解决" class="headerlink" title="与MySQL新建连接过程中报 2058 错误的解决"></a>与MySQL新建连接过程中报 2058 错误的解决</h2><ol>
<li><strong>以管理员身份运行命令行窗口</strong></li>
<li><strong>输入mysql检查是否配置了环境变量，没有则自行搜索方法并配置</strong></li>
<li><strong>mysql -u root -p登陆自己的本地MySQL数据库</strong></li>
<li><strong>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘yourPassword’;</strong></li>
<li><strong>重新去SQLyog建立连接</strong></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQLyog</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaSE】权限修饰符</title>
    <url>/2020/05/30/%E3%80%90JavaSE%E3%80%91%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>Java的访问权限修饰符总共有4中，依照权限大小的顺序依次为：</p>
<ol>
<li>public</li>
<li>protected</li>
<li>friendly(default)</li>
<li>private</li>
</ol>
<p>具体权限表示可以通过下面的表格来详细描述：</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>本类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>同包其他类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>不同包其他类</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
<tr>
<td>同包子类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>不同包子类</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody></table>
<p>可以看到private用有最低的权限，该修饰符下的类、属性或是方法只能由本类使用，其他类无法访问。</p>
<p>default权限属于包权限，该包下的所有类均可以访问，但其他包的任何类都无权访问。</p>
<p>protected属于子类权限，同包下的任何类可以访问，不同包下的类如果是该类的子类仍然可以访问该权限修饰符修饰的类、属性或是方法。</p>
<p>public拥有最高权限，任何类都可以访问。</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>class加载过程</title>
    <url>/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%5Cflow.jog" alt></p>
<p>加载过程</p>
<h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><ol>
<li><p><strong>双亲委派，主要出于安全来考虑</strong></p>
<p><img src="/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%5C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt></p>
<p>如图所示，即先向上找寻是否已加载过该类，相应的类加载器的缓存中是否有，有就返回。如果一直没有，就自上而下查看是否能够加载。</p>
<p>该机制是由ClassLoader中的loadClass方法来实现的，loadClass方法又调用了findClass方法，所以一般来自定义classLoader重写findClass方法即可，但要打破双亲委派机制需要重写loadClass方法。</p>
<ol>
<li><p>extends ClassLoader</p>
</li>
<li><p>overwrite findClass() -&gt; defineClass(byte[] -&gt; Class clazz)</p>
</li>
<li><p>加密 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T007_ClassLoaderWithEncription</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> seed = <span class="number">0B10110110</span>;<span class="comment">//不加密就不需要这一步</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"c:/test/"</span>, name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".sriclass"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b=fis.read()) !=<span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b ^ seed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        encFile(<span class="string">"com.sri.jvm.hello"</span>);</span><br><span class="line"></span><br><span class="line">        ClassLoader l = <span class="keyword">new</span> T007_MSBClassLoaderWithEncription();</span><br><span class="line">        Class clazz = l.loadClass(<span class="string">"com.sri.jvm.Hello"</span>);</span><br><span class="line">        Hello h = (Hello)clazz.newInstance();</span><br><span class="line">        h.m();</span><br><span class="line"></span><br><span class="line">        System.out.println(l.getClass().getClassLoader());</span><br><span class="line">        System.out.println(l.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encFile</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"c:/test/"</span>, name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"c:/test/"</span>, name.replaceAll(<span class="string">"."</span>, <span class="string">"/"</span>).concat(<span class="string">".sriclass"</span>)));</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b ^ seed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>何时打破过？</p>
<ol>
<li>JDK1.2之前，自定义ClassLoader都必须重写loadClass()</li>
<li>ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定</li>
<li>热启动，热部署<ol>
<li>osgi tomcat 都有自己的模块指定classloader（可以加载同一类库的不同版本）</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>   作用：</p>
<p>   ​    1是保证了资源不浪费，使得类只加载一次。</p>
<p>   ​    2是保证了安全。比如String类型属于核心类库不能修改，这样当定义同名类的时候会向上溯源查找返回sun定义好的String，而不会覆盖。</p>
<ol start="2">
<li><p><strong>LazyLoading 五种情况</strong></p>
<p>就是用的时候才会加载</p>
<p>–new getstatic putstatic invokestatic指令，访问final变量除外</p>
<p>–java.lang.reflect对类进行反射调用时</p>
<p>–初始化子类的时候，父类首先初始化</p>
<p>–虚拟机启动时，被执行的主类必须初始化</p>
<p>–动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化</p>
</li>
</ol>
<h3 id="linking"><a href="#linking" class="headerlink" title="linking"></a>linking</h3><ul>
<li><p>verification</p>
<p>校验是否符合class文件的标准，比如cafe babe开头，符合才会往下执行</p>
</li>
<li><p>preparation</p>
<p>对静态变量赋默认值</p>
</li>
<li><p>resolution</p>
<p>将类、方法、属性等符号引用解析为直接引用</p>
<p>常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</p>
</li>
</ul>
<h3 id="initializing"><a href="#initializing" class="headerlink" title="initializing"></a>initializing</h3><p>调用类的初始化代码，给静态变量赋为初值，执行静态代码块的内容。</p>
<ol>
<li>load - 默认值 - 初始值</li>
<li>new - 申请内存 - 默认值 - 初始值</li>
</ol>
<h3 id="类加载器的范围"><a href="#类加载器的范围" class="headerlink" title="类加载器的范围"></a>类加载器的范围</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T003_ClassLoaderScope</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pathBoot = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line">        System.out.println(pathBoot.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        String pathExt = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        System.out.println(pathExt.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        String pathApp = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">        System.out.println(pathApp.replaceAll(<span class="string">";"</span>, System.lineSeparator()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\resources.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\rt.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\sunrsasign.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jsse.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jce.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\charsets.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jfr.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\classes</span></span><br><span class="line"><span class="comment"> * --------------------</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext</span></span><br><span class="line"><span class="comment"> * C:\WINDOWS\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment"> * --------------------</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\charsets.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\deploy.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\access-bridge-64.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\cldrdata.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\dnsns.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jaccess.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\jfxrt.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\localedata.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\nashorn.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunec.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunjce_provider.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunmscapi.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\sunpkcs11.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\ext\zipfs.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\javaws.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jce.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jfr.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jfxswt.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\jsse.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\management-agent.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\plugin.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\resources.jar</span></span><br><span class="line"><span class="comment"> * D:\Program Files\Java\jdk1.8.0_231\jre\lib\rt.jar</span></span><br><span class="line"><span class="comment"> * D:\Users\Public\clone\JVM\out\production\JVM</span></span><br><span class="line"><span class="comment"> * D:\Program Files\JetBrains\IntelliJ IDEA 2019.3.2\lib\idea_rt.jar</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="lazyLoading"><a href="#lazyLoading" class="headerlink" title="lazyLoading"></a>lazyLoading</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T008_LazyLoading</span> </span>&#123; <span class="comment">//严格讲应该叫lazy initialzing，因为java虚拟机规范并没有严格规定什么时候必须loading,但严格规定了什么时候initialzing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        P p;</span><br><span class="line"><span class="comment">//        X x = new X(); // p X</span></span><br><span class="line"><span class="comment">//        System.out.println(P.i); // 8  fianl变量就不是在initializing这一步赋初始值的</span></span><br><span class="line">        System.out.println(P.j); <span class="comment">// p 9</span></span><br><span class="line"><span class="comment">//        Class.forName("com.sri.jvm.c2_classloader.T008_LazyLoading$P");</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"P"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"p+"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"X"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T012_ClassReloading2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"D:\\Users\\Public\\clone\\JVM\\out\\production\\JVM\\"</span> + name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>).concat(<span class="string">".class"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!f.exists()) <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                InputStream is = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                is.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyLoader m = <span class="keyword">new</span> MyLoader();</span><br><span class="line">        Class clazz = m.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        m = <span class="keyword">new</span> MyLoader();</span><br><span class="line">        Class clazzNew = m.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazzNew);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T006_MSBClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:\\Users\\Public\\clone\\JVM\\out\\production\\JVM"</span>, name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((b=fis.read()) !=<span class="number">0</span>) &#123;</span><br><span class="line">                baos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">            baos.close();</span><br><span class="line">            fis.close();<span class="comment">//可以写的更加严谨</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name); <span class="comment">//throws ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader l = <span class="keyword">new</span> T006_MSBClassLoader();</span><br><span class="line">        Class clazz = l.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line">        Class clazz1 = l.loadClass(<span class="string">"com.mashibing.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Hello h = (Hello)clazz.newInstance();</span><br><span class="line">        h.m();</span><br><span class="line"></span><br><span class="line">        System.out.println(l.getClass().getClassLoader());</span><br><span class="line">        System.out.println(l.getParent());</span><br><span class="line"></span><br><span class="line">        System.out.println(getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为只涉及到findClas方法的重写，其他的方法都是采用的父类或者其他类的方法，也是涉及到设计模式中的模板方法。在实现自己需要加载指定目录下的class文件，比如做框架的时候，spring  tomcat。</p>
<h2 id="java的执行"><a href="#java的执行" class="headerlink" title="java的执行"></a>java的执行</h2><p>默认是混合编译：解释执行和编译执行</p>
<p><img src="/2020/06/06/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%5CwayToRun.jpg" alt></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】测试图片显示问题</title>
    <url>/2020/06/03/%E3%80%90hexo%E3%80%91%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>测试图片：</p>
<p><img src="/2020/06/03/%E3%80%90hexo%E3%80%91%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/CPU_cache.jpg" alt></p>
<p>因为之前在网上看的使用npm install hexo-asset-image –save方式总是不能成功在网页上显示，但本地可以显示，就到处找解决方法一直不能成功，就换了一个插件来试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-image --save</span><br></pre></td></tr></table></figure>

<p>设置hexo配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true </span><br><span class="line"></span><br><span class="line">filter_image:</span><br><span class="line"></span><br><span class="line">  log: true</span><br></pre></td></tr></table></figure>

<p>然后在插入图片的位置输入相对路径，图片存放在和博客文章同级的同名目录下。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【javaSE】关键字</title>
    <url>/2020/05/26/%E3%80%90javaSE%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>Java关键字是预先定义好的，有特殊意义的标识符。在Java语言中关键字一律小写。关键字不可以用作变量名、方法名、类名、包名和参数类型。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>表明类或者成员方法具有抽象属性</td>
</tr>
<tr>
<td>assert</td>
<td>断言</td>
</tr>
<tr>
<td>boolean</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>break</td>
<td>用于在循环语句中跳出当前循环或配合label使用</td>
</tr>
<tr>
<td>byte</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>case</td>
<td>用在switch语句之中，表示其中的一个分支</td>
</tr>
<tr>
<td>catch</td>
<td>用在异常处理中，用来捕捉异常</td>
</tr>
<tr>
<td>char</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>class</td>
<td>声明一个类</td>
</tr>
<tr>
<td>continue</td>
<td>跳过<strong>本次</strong>循环执行，到下一次循环开始处</td>
</tr>
<tr>
<td>default</td>
<td>默认，例如，用在switch语句中，表明一个默认的分支</td>
</tr>
<tr>
<td>do</td>
<td>用在do-while循环结构中，必执行一次循环体</td>
</tr>
<tr>
<td>double</td>
<td>基本数据类型，浮点数默认类型</td>
</tr>
<tr>
<td>else</td>
<td>用在条件语句中，表明当条件不成立时的分支</td>
</tr>
<tr>
<td>enum</td>
<td>定义枚举类</td>
</tr>
<tr>
<td>extends</td>
<td>继承，可以继承类或者抽象类，不能继承接口，继承抽象类的抽象方法也必须重写，但是抽象类里面的未声明abstract的方法可不重写</td>
</tr>
<tr>
<td>final</td>
<td>用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</td>
</tr>
<tr>
<td>finally</td>
<td>用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</td>
</tr>
<tr>
<td>float</td>
<td>基本数据类型，使用的时候数字后面跟f或F</td>
</tr>
<tr>
<td>for</td>
<td>一种循环结构的引导词</td>
</tr>
<tr>
<td>if</td>
<td>条件语句的引导词</td>
</tr>
<tr>
<td>implements</td>
<td>实现，Java多实现</td>
</tr>
<tr>
<td>import</td>
<td>表明要访问指定的类或包</td>
</tr>
<tr>
<td>instanceof</td>
<td>用来测试一个对象是否是指定类型的实例对象</td>
</tr>
<tr>
<td>int</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
</tr>
<tr>
<td>long</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>native</td>
<td>用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的</td>
</tr>
<tr>
<td>new</td>
<td>用来创建新实例对象</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
</tr>
<tr>
<td>private</td>
<td>一种访问控制方式：私用模式</td>
</tr>
<tr>
<td>protected</td>
<td>一种访问控制方式：保护模式</td>
</tr>
<tr>
<td>public</td>
<td>一种访问控制方式：共用模式</td>
</tr>
<tr>
<td>return</td>
<td>从成员方法中返回数据，也可用在循环中，但是就直接跳出该方法了</td>
</tr>
<tr>
<td>short</td>
<td>基本数据类型</td>
</tr>
<tr>
<td>static</td>
<td>表明具有静态属性</td>
</tr>
<tr>
<td>strictfp</td>
<td>strict float point 精确浮点</td>
</tr>
<tr>
<td>super</td>
<td>表明当前对象的父类型的引用或者父类型的构造方法</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句结构的引导词</td>
</tr>
<tr>
<td>synchronized</td>
<td>同步</td>
</tr>
<tr>
<td>this</td>
<td>指向当前实例对象的引用</td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常，方法体内</td>
</tr>
<tr>
<td>throws</td>
<td>声明在当前成员方法中所有需要抛出的异常，在方法声明处，异常用,隔开</td>
</tr>
<tr>
<td>transient</td>
<td>声明不用序列化的成员域</td>
</tr>
<tr>
<td>try</td>
<td>尝试一个可能抛出异常的程序块</td>
</tr>
<tr>
<td>void</td>
<td>声明当前成员方法没有返回值</td>
</tr>
<tr>
<td>volatile</td>
<td>表明两个或者多个变量必须同步地发生变化</td>
</tr>
<tr>
<td>while</td>
<td>用在循环结构中</td>
</tr>
<tr>
<td>const</td>
<td>用于修改字段或局部变量的声明。它指定字段或局部变量的值是常数，不能被修改</td>
</tr>
<tr>
<td>goto</td>
<td>指定跳转到标签，找到标签后，程序将处理从下一行开始的命令</td>
</tr>
<tr>
<td>true</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>static主要有四种使用场景</strong></p>
<ul>
<li><p><strong>修饰成员变量和成员方法：</strong>被static修饰的成员变量或方法属于当前的类，而非某个特定的实例对象，被类的所有对象共享。可以通过类名调用，成员变量属于静态成员变量，存放在Java内存区域中的方法区。</p>
</li>
<li><p><strong>静态代码块：</strong>静态代码块定义在类中的方法外，静态代码块在非静态代码块之前执行（静态代码块-&gt;非静态代码块-&gt;构造方法）。静态代码块只会执行一次，不论该类创造了多少对象。</p>
</li>
<li><p><strong>静态内部类（static可以修饰类，但是只能修饰内部类）：</strong>静态内部类与非静态内部类之间存在一个最大的区别是：非静态内部类在编译完成之后会隐式地保存着一个引用，<strong>该引用指向创建它的外部类</strong>，但是静态内部类是在外部类加载的时候也加载的，并没有这个隐含地引用。没有这个引用也就意味着：1.它的创建是不需要依赖外部类的创建。2.它不能使用外部类得到非static成员变量和成员方法。因为静态嘛，静态无法使用非静态的东西。</p>
</li>
<li><p><strong>静态导包（用来导入类中的静态资源，1.5之后的新特性）：</strong>格式为import static …</p>
<p> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中的静态成员，可以直接使用类中的静态成员变量和成员方法。也就是说本来在该类中可以通过</p>
<p>类名.静态方法() 类名.静态变量  的方式来调用，现在不需要加上类名.这个前缀了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_01</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">static_01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"非静态代码块，也称构造代码块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"共有的静态方法"</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"静态方法中的非静态代码块"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 System.out.println(<span class="string">"main方法体"</span>);</span><br><span class="line">		 &#123;</span><br><span class="line">			 System.out.println(<span class="string">"main方法非静态代码块"</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 static_01 o1 = <span class="keyword">new</span> static_01();</span><br><span class="line">		 o1.method01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> keyWords;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">static_02</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		static_01 o2 = <span class="keyword">new</span> static_01();</span><br><span class="line">		static_01 o3 = <span class="keyword">new</span> static_01();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">非静态代码块，也称构造代码块</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行该类main方法结果为：</span><br><span class="line"></span><br><span class="line">静态代码块</span><br><span class="line">main方法体</span><br><span class="line">main方法非静态代码块</span><br><span class="line">非静态代码块，也称构造代码块</span><br><span class="line">构造方法</span><br><span class="line">共有的静态方法</span><br><span class="line">静态方法中的非静态代码块</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">可以看到静态代码块是首先执行的，而非静态代码块是在创建对象的时候才执行，而如果静态代码块已经执行过就不会再执行了，而非静态代码块在每创建一个对象的时候都会执行。</span><br></pre></td></tr></table></figure>

<p>非静态代码块与构造函数的区别是：非静态代码块是给所有对象进行统一的初始化，而构造函数是给对应的对象初始化，因构造函数是可以多个的，运行什么样的构造函数创建什么样的对象，但是无论创建哪个对象都会执行相同的构造代码块。共性和个性的区别。</p>
<p><strong>补充：</strong></p>
<p>关于Class.forName方法加载类</p>
<p>查看API可知，调用Class.forName(“package.className”)的方式实际上是等价于调用Class.forName(className, true, currentLoader)  (ClassLoader.getSystemClassLoader())</p>
<p>因此在加载类的时候就做了类的初始化操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;static_01&gt; clazz = static_01<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//只是单纯的加载类，不会初始化，即没有使用数据</span></span><br><span class="line">            static_01 static_01 = static_01<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;<span class="comment">//静态代码块-非静态代码块-构造方法</span></span><br><span class="line"><span class="comment">//            static_01 s1 = new static_01();</span></span><br><span class="line"><span class="comment">//            static_01 s2 = new static_01();</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"shu.keyWords.static_01"</span>,<span class="keyword">false</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码取消初始化操作之后就不会执行静态代码块，只是将类加载成字节码文件。</p>
<p>其中new是强类型，相对高效，能调用任何public构造方法。newInstance是弱类型，相对低效，只能调用无参构造。</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li><p><strong>final修饰变量，则等同于常量</strong>.</p>
<p>​        final修饰变量是使用最多的地方。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能指向另一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Person person;</span><br><span class="line">    <span class="comment">//如果同时加了static 和 final 就必须立刻赋初始值，因为static在构造方法之前加载的</span></span><br><span class="line"><span class="comment">//只加其中一个修饰关键字是都可以在构造方法赋值的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">        person.setAge(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//    public FinalTest01() &#123;</span></span><br><span class="line"><span class="comment">//        super();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//这个时候会报错，也就是说所有的构造方法都必须对这个final成员变量赋值</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalTest finalTest = <span class="keyword">new</span> FinalTest(<span class="keyword">new</span> Person());</span><br><span class="line">        System.out.println(finalTest.person.getAge());<span class="comment">//11</span></span><br><span class="line">        finalTest.person.setAge(<span class="number">13</span>);</span><br><span class="line">        System.out.println(finalTest.person.getAge());<span class="comment">//13</span></span><br><span class="line">        <span class="comment">//final成员变量必须让所有的构造方法赋初始值，且引用类型变量地址值不可变，变量的内部属性可以通过自己的方法来改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">    在某偏博客还是帖子看到的例子：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = <span class="string">"hello"</span>;</span><br><span class="line">        String d = <span class="string">"hello"</span>;</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        String e = d + <span class="number">2</span>;</span><br><span class="line">        System.out.println((a == c));</span><br><span class="line">        System.out.println((a == e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出结果：true、false</span></span><br><span class="line"><span class="comment">     大家可以先想一下这道题的输出结果。为什么第一个比较结果为true，而第二个比较结果为fasle。这里面就是final变量和普通变量的区别了，当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。因此在上面的一段代码中，由于变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b 替换为它的值。而对于变量d的访问却需要在运行时通过链接来进行。想必其中的区别大家应该明白了，不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化，比如下面的这段代码就不会进行优化：    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = getHello();</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        System.out.println((a == c));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码的输出结果为false。这里要注意一点就是：不要以为某些数据是final就可以在编译期知道其值，通过变量b我们就知道了，在这里是使用getHello()方法对其进行初始化，他要在运行期才能知道其值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>final修饰方法参数列表中的参数，称为最终参数。</strong></p>
</li>
<li><p><strong>final修饰类，则类不能被继承</strong>。final类中的所有成员方法都会被隐式地指定为final方法。</p>
</li>
<li><p><strong>final修饰方法，则方法不能被重写。</strong></p>
<p>​        使用final修饰方法的原因有两个，1是将方法锁定，以防止任何继承类修改它的含义；2是因为效率，在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能会看不到内嵌调用带来的性能提升。现在的版本已经不需要使用final来进行这样的优化了，类中所有的private方法都会隐式地指定为final。</p>
<p>　    因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即<strong>父类的final方法是不能被子类所覆盖的</strong>，也就是说子类是不能够存在和父类一模一样的方法的。</p>
<pre><code>final修饰的方法表示此方法已经是“**最后的、最终的**”含义，亦即**此方法不能被重写**（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</code></pre></li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this关键字用于引用当前类的<strong>实例</strong>。</p>
<p>所以要注意哪些地方才可以使用this关键字。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super关键字用于从子类访问父类的变量和方法</p>
]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/05/30/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>值传递：</p>
<p>​    java参数传递采用的是值传递，对于<strong>基本类型的变量</strong>，相当于直接将变量进行了拷贝，在方法内部改变了变量i的值也不会影响方法外的i。</p>
<p>​    对于引用变量，传递的是引用的值，也就是说让实参和形参同时指向了同一个对象，因此让形参重新指向另一个对象对实参并没有任何影响。</p>
<p>简单定义：定义在一个类内部的类就叫内部类。</p>
<p>内部类也是一个很困惑的点了。</p>
<p>首先是分类，内部类可以按照所在区域的不同分为以下四种：</p>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态内部类</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>参考：<a href="https://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenssy/p/3388487.html</a></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><h2 id="内部类详解"><a href="#内部类详解" class="headerlink" title="内部类详解"></a>内部类详解</h2><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/06/08/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树的基本算法"><a href="#二叉树的基本算法" class="headerlink" title="二叉树的基本算法"></a>二叉树的基本算法</h2><p>先序：头 -  左 - 右</p>
<p>中序：左 - 头 - 右</p>
<p>后序：左 - 右 - 头</p>
<h3 id="用-栈-实现二叉树的先序-中序-后续-遍历"><a href="#用-栈-实现二叉树的先序-中序-后续-遍历" class="headerlink" title="用 栈 实现二叉树的先序 中序 后续 遍历"></a>用 栈 实现二叉树的先序 中序 后续 遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> Node left;</span><br><span class="line">   <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">      value = v;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      stack.add(head);</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">         head = stack.pop();</span><br><span class="line">         System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">         <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head.right);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head.left);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.right;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个栈实现后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      s1.push(head);</span><br><span class="line">      <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">         head = s1.pop();</span><br><span class="line">         s2.push(head);</span><br><span class="line">         <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(head.left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s1.push(head.right);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">         System.out.print(s2.pop().value + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个栈实现后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos2</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">   System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">   <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">      stack.push(h);</span><br><span class="line">      Node c = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">         c = stack.peek();</span><br><span class="line">         <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">            stack.push(c.left);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; h != c.right) &#123;</span><br><span class="line">            stack.push(c.right);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">            h = c;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的按层遍历"><a href="#二叉树的按层遍历" class="headerlink" title="二叉树的按层遍历"></a>二叉树的按层遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以队列实现二叉树的按层遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">level</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   queue.add(head);</span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      Node cur = queue.poll();<span class="comment">//linkedList方法，返回队头的节点并释放</span></span><br><span class="line">      System.out.println(cur.value);</span><br><span class="line">      <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用Map实现返回二叉树的最大宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthUseMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   queue.add(head);</span><br><span class="line">   <span class="comment">// key 在 哪一层，value</span></span><br><span class="line">   HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">int</span> curLevel = <span class="number">1</span>; <span class="comment">// 当前你正在统计哪一层的宽度</span></span><br><span class="line">   <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      Node cur = queue.poll();</span><br><span class="line">      <span class="keyword">int</span> curNodeLevel = levelMap.get(cur);</span><br><span class="line">      <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">         curLevelNodes++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         max = Math.max(max, curLevelNodes);</span><br><span class="line">         curLevel++;</span><br><span class="line">         curLevelNodes = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   max = Math.max(max, curLevelNodes);</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不是用Map实现返回二叉树的最大宽度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   queue.add(head);</span><br><span class="line">   Node curEnd = head; <span class="comment">// 当前层，最右节点是谁</span></span><br><span class="line">   Node nextEnd = <span class="keyword">null</span>; <span class="comment">// 下一层，最右节点是谁</span></span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      Node cur = queue.poll();</span><br><span class="line">      <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.left);</span><br><span class="line">         nextEnd = cur.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(cur.right);</span><br><span class="line">         nextEnd = cur.right;</span><br><span class="line">      &#125;</span><br><span class="line">      curLevelNodes++;</span><br><span class="line">      <span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">         max = Math.max(max, curLevelNodes);</span><br><span class="line">         curLevelNodes = <span class="number">0</span>;</span><br><span class="line">         curEnd = nextEnd;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，</span></span><br><span class="line"><span class="comment"> * 以下代码全部实现了。</span></span><br><span class="line"><span class="comment"> * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化</span></span><br><span class="line"><span class="comment"> * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。</span></span><br><span class="line"><span class="comment"> * 比如如下两棵树</span></span><br><span class="line"><span class="comment"> *         __2</span></span><br><span class="line"><span class="comment"> *        /</span></span><br><span class="line"><span class="comment"> *       1</span></span><br><span class="line"><span class="comment"> *       和</span></span><br><span class="line"><span class="comment"> *       1__</span></span><br><span class="line"><span class="comment"> *          \</span></span><br><span class="line"><span class="comment"> *           2</span></span><br><span class="line"><span class="comment"> * 补足空位置的中序遍历结果都是&#123; null, 1, null, 2, null&#125;</span></span><br><span class="line"><span class="comment"> *       </span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>

<p>序列化和反序列化，将二叉树的节点值按照字符串保存下来，并保存它的数据结构信息以便重构回内存，空的节点以null值补齐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">preSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   pres(head, ans);</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pres</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ans.add(<span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ans.add(String.valueOf(head.value));</span><br><span class="line">      pres(head.left, ans);</span><br><span class="line">      pres(head.right, ans);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序反序列化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByPreQueue</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (prelist == <span class="keyword">null</span> || prelist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> preb(prelist);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">preb</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>&#123;</span><br><span class="line">		String value = prelist.poll();</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">		head.left = preb(prelist);</span><br><span class="line">		head.right = preb(prelist);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">posSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   poss(head, ans);</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">poss</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ans.add(<span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      poss(head.left, ans);</span><br><span class="line">      poss(head.right, ans);</span><br><span class="line">      ans.add(String.valueOf(head.value));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序反序列化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByPosQueue</span><span class="params">(Queue&lt;String&gt; poslist)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (prelist == <span class="keyword">null</span> || prelist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="comment">// 左右中  -&gt;  stack(中右左)</span></span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!poslist.isEmpty()) &#123;</span><br><span class="line">			stack.push(poslist.poll());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> posb(stack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">posb</span><span class="params">(Stack&lt;String&gt; posstack)</span> </span>&#123;</span><br><span class="line">		String value = posstack.pop();</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">		head.right = posb(posstack);</span><br><span class="line">		head.left = posb(posstack);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">levelSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">      Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">         ans.add(<span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         ans.add(String.valueOf(head.value));</span><br><span class="line">         Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">         queue.add(head);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(String.valueOf(head.left.value));</span><br><span class="line">               queue.add(head.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(String.valueOf(head.right.value));</span><br><span class="line">               queue.add(head.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按层反序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildByLevelQueue</span><span class="params">(Queue&lt;String&gt; levelList)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (levelList == <span class="keyword">null</span> || levelList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Node head = generateNode(levelList.poll());</span><br><span class="line">      Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">      <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         queue.add(head);</span><br><span class="line">      &#125;</span><br><span class="line">      Node node = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">         node = queue.poll();</span><br><span class="line">         node.left = generateNode(levelList.poll());</span><br><span class="line">         node.right = generateNode(levelList.poll());</span><br><span class="line">         <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateNode</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归序"><a href="#递归序" class="headerlink" title="递归序"></a>递归序</h3><h3 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h3><h3 id="获取二叉树某个节点的后继节点"><a href="#获取二叉树某个节点的后继节点" class="headerlink" title="获取二叉树某个节点的后继节点"></a>获取二叉树某个节点的后继节点</h3><p>重新定义二叉树的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Node &#123;</span><br><span class="line"></span><br><span class="line"> 	V value;</span><br><span class="line"></span><br><span class="line"> 	Node left;</span><br><span class="line"></span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	Node parent;<span class="comment">//多定义了指向父节点的指针</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后继节点即为整棵二叉树以中序遍历输出之后，当前节点的下一个输出节点。</p>
<p>因此暴力解法可以通过父节点指针找到头结点，将整棵二叉树中序遍历来得到顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> Node left;</span><br><span class="line">   <span class="keyword">public</span> Node right;</span><br><span class="line">   <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无右子树</span></span><br><span class="line">      Node parent = node.parent;</span><br><span class="line">      <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.right == node) &#123; <span class="comment">// 当前节点是其父亲节点右孩子</span></span><br><span class="line">         node = parent;</span><br><span class="line">         parent = node.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> parent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			node = node.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取二叉树某个节点的前驱节点"><a href="#获取二叉树某个节点的前驱节点" class="headerlink" title="获取二叉树某个节点的前驱节点"></a>获取二叉树某个节点的前驱节点</h3><p>前驱节点，即后继节点概念下，当前节点的前一个输出。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p>
<p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 </p>
<p>例如:N=2时，打印: down down up   凹凹凸</p>
<p>观察可以得知，每次折痕的上部距已有折痕1/2处会出现凹折痕，下部距已有折痕1/2处会出现凸折痕。可以以二叉树的结构来表示。</p>
<p><img src="/2020/06/08/%E4%BA%8C%E5%8F%89%E6%A0%91/Folder.png" alt></p>
<p>这颗二叉树的所有左子树都是凹折痕，右子树都是凸折痕。想要将纸上的折痕方向自上而下打印，即将这颗二叉树进行中序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">   printProcess(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归过程，来到了某一个节点，</span></span><br><span class="line"><span class="comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">   System.out.println(down ? <span class="string">"凹 "</span> : <span class="string">"凸 "</span>);</span><br><span class="line">   printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿递归模拟出了这颗二叉树。空间复杂度只需要一个递归栈O(N).</p>
<h2 id="二叉树的递归方法"><a href="#二叉树的递归方法" class="headerlink" title="二叉树的递归方法"></a>二叉树的递归方法</h2><h3 id="二叉树的递归套路流程"><a href="#二叉树的递归套路流程" class="headerlink" title="二叉树的递归套路流程"></a>二叉树的递归套路流程</h3><ul>
<li>1）假设以X节点为头，假设可以向X左树和X右树要任何信息</li>
<li>2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</li>
<li>3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</li>
<li>4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S   因为是递归，所以不想要区分左右子树</li>
<li>5）递归函数都返回S，每一棵子树都这么要求</li>
<li>6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</li>
</ul>
<h3 id="返回是否平衡二叉树"><a href="#返回是否平衡二叉树" class="headerlink" title="返回是否平衡二叉树"></a>返回是否平衡二叉树</h3><p>平衡二叉树：</p>
<p>​    节点左子树和右子树的高度差不大于1，必须所有子树的满足这个要求，整棵树才称为平衡二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> Node left;</span><br><span class="line">   <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span>[] ans = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">   ans[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">   process1(head, ans);</span><br><span class="line">   <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(Node head, <span class="keyword">boolean</span>[] ans)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!ans[<span class="number">0</span>] || head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> leftHeight = process1(head.left, ans);</span><br><span class="line">		<span class="keyword">int</span> rightHeight = process1(head.right, ans);</span><br><span class="line">		<span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			ans[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>第二种方式</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> process2(head).isBalaced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左、右要求一样，Info 信息返回的结构体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为我的要求是左子树和右子树首先得是平衡二叉树，然后看以我当前节点为头结点，二者的高度差</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">boolean</span> isBalaced;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">      isBalaced = b;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process2</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//空节点了嘛，当然是平衡的了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Info leftInfo = process2(X.left);</span><br><span class="line">   Info rightInfo = process2(X.right);</span><br><span class="line">   <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果</span></span><br><span class="line">    <span class="comment">//左子树不平衡 或者 右子树不平衡 或者 二者的高度差大于1</span></span><br><span class="line">    <span class="comment">//返回当前二叉树不平衡</span></span><br><span class="line">   <span class="keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      isBalanced = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateRandomBST</span><span class="params">(<span class="keyword">int</span> maxLevel, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> generate(<span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generate</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> maxLevel, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (level &gt; maxLevel || Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Node head = <span class="keyword">new</span> Node((<span class="keyword">int</span>) (Math.random() * maxValue));</span><br><span class="line">   head.left = generate(level + <span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">   head.right = generate(level + <span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxLevel = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> testTimes = <span class="number">1000000</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">      Node head = generateRandomBST(maxLevel, maxValue);</span><br><span class="line">      <span class="keyword">if</span> (isBalanced1(head) != isBalanced2(head)) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Oops!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">"finish!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="返回节点的最大距离"><a href="#返回节点的最大距离" class="headerlink" title="返回节点的最大距离"></a>返回节点的最大距离</h3><p>稍难的是列出所有可能性</p>
<p>以是否考虑头结点来划分成两个大类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> dis, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">      maxDistance = dis;</span><br><span class="line">      height = h;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Info leftInfo = process(X.left);</span><br><span class="line">   Info rightInfo = process(X.right);</span><br><span class="line">   <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> maxDistance = Math.max(</span><br><span class="line">         Math.max(leftInfo.maxDistance, rightInfo.maxDistance),</span><br><span class="line">         leftInfo.height + rightInfo.height + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Info(maxDistance, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大二叉搜索子树"><a href="#最大二叉搜索子树" class="headerlink" title="最大二叉搜索子树"></a>最大二叉搜索子树</h3><p>Binary Search Tree</p>
<p>搜索二叉树</p>
<p><code>BST</code> 整棵树没有重复值(好像是废话 - -），每棵树的左节点比头节点小，右节点比头节点大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBSTSize</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ArrayList&lt;Node&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   in(head, arr);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.get(i).value &lt;= arr.get(i - <span class="number">1</span>).value) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head, ArrayList&lt;Node&gt; arr)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   in(head.left, arr);</span><br><span class="line">   arr.add(head);</span><br><span class="line">   in(head.right, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubBSTSize1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> h = getBSTSize(head);</span><br><span class="line">   <span class="keyword">if</span> (h != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Math.max(maxSubBSTSize1(head.left), maxSubBSTSize1(head.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubBSTSize2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> process(head).maxSubBSTSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 任何子树</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> isAllBST;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> maxSubBSTSize;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> is, <span class="keyword">int</span> size, <span class="keyword">int</span> mi, <span class="keyword">int</span> ma)</span> </span>&#123;</span><br><span class="line">			isAllBST = is;</span><br><span class="line">			maxSubBSTSize = size;</span><br><span class="line">			min = mi;</span><br><span class="line">			max = ma;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(X == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Info leftInfo = process(X.left);</span><br><span class="line">		Info rightInfo = process(X.right);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> min = X.value;</span><br><span class="line">		<span class="keyword">int</span> max = X.value;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			min = Math.min(min, leftInfo.min);</span><br><span class="line">			max = Math.max(max, leftInfo.max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			min = Math.min(min, rightInfo.min);</span><br><span class="line">			max = Math.max(max, rightInfo.max);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> maxSubBSTSize = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			maxSubBSTSize = leftInfo.maxSubBSTSize;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rightInfo !=<span class="keyword">null</span>) &#123;</span><br><span class="line">			maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(</span><br><span class="line">				<span class="comment">// 左树整体需要是搜索二叉树</span></span><br><span class="line">				(  leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST    )</span><br><span class="line">				&amp;&amp;</span><br><span class="line">				(  rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST    )</span><br><span class="line">				&amp;&amp;</span><br><span class="line">				<span class="comment">// 左树最大值&lt;x</span></span><br><span class="line">				(leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.max &lt; X.value)</span><br><span class="line">				&amp;&amp;</span><br><span class="line">				(rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.min &gt; X.value)</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">				) &#123;</span><br><span class="line">			</span><br><span class="line">			maxSubBSTSize = </span><br><span class="line">					(leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize)</span><br><span class="line">					+</span><br><span class="line">					(rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize)</span><br><span class="line">					+</span><br><span class="line">					<span class="number">1</span>;</span><br><span class="line">					isAllBST = <span class="keyword">true</span>;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(isAllBST, maxSubBSTSize, min, max);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h3 id="排队最大快乐值"><a href="#排队最大快乐值" class="headerlink" title="排队最大快乐值"></a>排队最大快乐值</h3><p>描述：</p>
<p>公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p>
<p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</p>
<p>1.如果某个员工来了，那么这个员工的所有<strong>直接</strong>下级都不能来</p>
<p>2.派对的整体快乐值是所有到场员工快乐值的累加</p>
<p>3.你的目标是让派对的整体快乐值尽量大</p>
<p>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</p>
<p>员工信息的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> happy; <span class="comment">// 这名员工可以带来的快乐值</span></span><br><span class="line"></span><br><span class="line">  List&lt;Employee&gt; subordinates; <span class="comment">// 这名员工有哪些直接下级</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappy1</span><span class="params">(Employee boss)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (boss == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> process1(boss, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(Employee cur, <span class="keyword">boolean</span> up)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (up) &#123;</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Employee next : cur.nexts) &#123;</span><br><span class="line">         ans += process1(next, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> p1 = cur.happy;</span><br><span class="line">      <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (Employee next : cur.nexts) &#123;</span><br><span class="line">         p1 += process1(next, <span class="keyword">true</span>);</span><br><span class="line">         p2 += process1(next, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxHappy2</span><span class="params">(Employee boss)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (boss == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Info all = process2(boss);</span><br><span class="line">   <span class="keyword">return</span> Math.max(all.yes, all.no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> yes;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      yes = y;</span><br><span class="line">      no = n;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process2</span><span class="params">(Employee x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x.nexts.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Info(x.happy, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> yes = x.happy;</span><br><span class="line">   <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (Employee next : x.nexts) &#123;</span><br><span class="line">      Info nextInfo = process2(next);</span><br><span class="line">      yes += nextInfo.no;</span><br><span class="line">      no += Math.max(nextInfo.yes, nextInfo.no);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Info(yes, no);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome插件</title>
    <url>/2020/06/02/chrome%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="插件的离线下载方式"><a href="#插件的离线下载方式" class="headerlink" title="插件的离线下载方式"></a>插件的离线下载方式</h2><ol>
<li><p>去应用商店自行下载</p>
</li>
<li><p>离线安装</p>
<p>下载需要安装 Chrome 扩展的 CRX 文件，并将其后缀名改为 ZIP 格式。然后解压缩这个 Chrome 扩展包文件。</p>
<p>点击你的 Chrome 浏览器中的「更多工具 &gt; 扩展程序」菜单或者直接在地址栏输入: chrome://extensions/ 打开扩展程序管理页面。</p>
<p>在打开的扩展程序管理页面上，选择开发者模式，点击 「加载已解压的扩展程序」。</p>
<p>选择前面解压缩的安装包所在的目录并确认后就完成了该插件的安装。</p>
</li>
</ol>
<h2 id="插件下载地址"><a href="#插件下载地址" class="headerlink" title="插件下载地址"></a>插件下载地址</h2><ul>
<li><p><strong>Crx4Chrome</strong></p>
<p>链接：<a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">https://www.crx4chrome.com/</a></p>
<p>包含了一些扩展排行，可以帮助探索新颖的好用的工具。</p>
</li>
</ul>
<ul>
<li><p><strong>扩展迷</strong></p>
<p>链接：<a href="https://extfans.com/" target="_blank" rel="noopener">https://extfans.com/</a></p>
<p>提供 Chrome 商店中优秀的 Chrome 插件推荐与下载服务。</p>
</li>
</ul>
<ul>
<li><p><strong>chrome插件网</strong></p>
<p>链接：<a href="http://chromecj.com/" target="_blank" rel="noopener">http://chromecj.com/</a></p>
<p>Chrome 插件网致力于帮助用户找到、安装、学会使用优秀的 Chrome 插件来提高谷歌浏览器的使用体验。</p>
</li>
</ul>
<h2 id="GitZip-for-Github"><a href="#GitZip-for-Github" class="headerlink" title="GitZip for Github"></a>GitZip for Github</h2><p>一个方便用户下载github资源的Chrome插件，有时候只是想要github某个仓库的部分文件而不是下载整个仓库，但原生的git命令不支持，所以在网上搜索可行的方法。</p>
<p>GitZip的使用很简单，在需要下载的仓库的某个文件或文件夹前面的空白处双击就会出现一个勾，可以选择多个文件或文件夹，这时候页面会弹出下载的按键，选择好之后点击下载即可，下载速度感觉比clone要快0.0</p>
<p>如果你觉得安装插件比较麻烦的话，也同样可以直接使用  GitZip for Github 的 Web 版本。方法类似，这里就不再赘述了。</p>
<p>Web 版本地址：<a href="https://kinolien.github.io/gitzip/" target="_blank" rel="noopener">https://kinolien.github.io/gitzip/</a></p>
<p>除了这个之外，也还有许多其他的方式来满足下载单项资源。</p>
<ul>
<li><p><a href="http://zhoudaxiaa.gitee.io/downgit/#/home" target="_blank" rel="noopener">DownGit</a></p>
</li>
<li><p><a href="https://www.runoob.com/svn/tortoisesvn-intro.html" target="_blank" rel="noopener">TotoiseSVN</a></p>
</li>
<li><p><a href="https://github.com/hua1995116/git-down-repo" target="_blank" rel="noopener">git-down-repo</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install git-down-repo -g <span class="comment">// 安装全局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test </span></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat  // 下载整个仓库（默认master）</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat dev // 下载某个仓库的dev分支</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/tree/master/config // 下载仓库某个文件夹</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/blob/master/config/dev.env.js // 下载某个文件</span></span><br><span class="line"></span><br><span class="line">gitdown https:<span class="comment">//github.com/hua1995116/webchat/blob/master/config/dev.env.js https://github.com/hua1995116/webpack-plugin-inner-script/blob/master/index.js // 下载多个项目（空格分隔）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>参考：</strong><a href="https://blog.csdn.net/weixin_44058333/article/details/97138348" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44058333/article/details/97138348</a></p>
<p>​            <a href="https://cloud.tencent.com/developer/article/1463081" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1463081</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>冲浪小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>底层基础知识01</title>
    <url>/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>计算机需要解决的最根本问题其实是：如何代表数字</p>
<h2 id="汇编语言（机器语言）的执行过程"><a href="#汇编语言（机器语言）的执行过程" class="headerlink" title="汇编语言（机器语言）的执行过程"></a>汇编语言（机器语言）的执行过程</h2><p>汇编语言的本质是机器语言的助记符，其实就是机器语言。</p>
<p>使用一些便于人理解的符号来表示一些操作，比如add sub等。</p>
<p>执行流程：</p>
<p>​        计算机通电-&gt; CPU读取内存中的程序（电信号输入） -&gt; <strong>时钟发生器</strong>不断的震荡通断电 -&gt; 推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期） -&gt; 计算完成 -&gt; 写回（电信号）   -&gt; 写给显卡输出</p>
<h2 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h2><p>PC ： Program Counter 程序计数器（记录当前指令地址）</p>
<p>​        记录当前指令占位多少，来推断下一指令的位置。</p>
<p>Register（寄存器） ： 暂时储存CPU计算需要用到的数据</p>
<p>ALU ： Arithmetic &amp; Logic Unit 运算和逻辑单元</p>
<p>CU ： Control Unit 控制单元</p>
<p>MMU ： Memory Management Unit 内存管理单元</p>
<p>Cache : L1 L2 L3(多核共享)</p>
<h2 id="CPU的制作与原理"><a href="#CPU的制作与原理" class="headerlink" title="CPU的制作与原理"></a>CPU的制作与原理</h2><p><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="noopener">https://www.sohu.com/a/255397866_468626</a></p>
<p><a href="https://www.bilibili.com/video/av47388949?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av47388949?p=2</a></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-CPU缓存层次"><a href="#1-CPU缓存层次" class="headerlink" title="1.CPU缓存层次"></a>1.CPU缓存层次</h3><p>现代CPU的储存结构如下图所示。</p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/CPU_cache.jpg" alt></p>
<p>SRAM: Static Random-Access Memory 静态随机存取器。静态是指只要保持通电状态，其内储存的数据就能恒常保持。</p>
<p>DRAM： Dynamic Random Access Memory动态随机存取储存器。动态指其内的数据需要周期性的更新，否则会导致数据出错。</p>
<p>为了缓和CPU运算速度远快于从内存读取数据的速度的矛盾，引入了缓存。</p>
<ul>
<li>L1高速缓存：也叫一级缓存。一般内置在内核旁边，是与CPU结合最为紧密的CPU缓存。一次访问只需要2~4个时钟周期</li>
<li>L2高速缓存：也叫二级缓存。空间比L1缓存大，速度比L1缓存略慢。一次访问约需要10多个时钟周期</li>
<li>L3高速缓存：也叫三级缓存。部分单CPU多核心的才会有的缓存，介于多核和内存之间。存储空间已达Mb级别，一次访问约需要数十个时钟周期</li>
</ul>
<p>对于多核处理器，L3是每个CPU内共享的，L1 L2 及寄存器是每个核独有的。</p>
<h3 id="总线锁及缓存锁"><a href="#总线锁及缓存锁" class="headerlink" title="总线锁及缓存锁"></a>总线锁及缓存锁</h3><p>总线锁：锁住总线。通过处理器发出lock指令，总线接收到指令后，其他处理器的请求就会被阻塞，直到此处理器执行完成。这样处理器可以独占共享内存，但因此其他的处理器就只能阻塞等待，无法发挥多处理的优势。</p>
<p>缓存锁：锁定被缓存的共享对象。接收到lock指令，通过缓存一致性协议，维护本处理器内部缓存和其他处理器缓存的一致性。</p>
<h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>虽然每次CPU需要使用的数据可能只有一小块，但是因为程序运行的局部性原理，提出了缓存行的概念。即一次读取一块内存数据放入缓存，即为缓存行。缓存行（cache line）是CPU缓存中可分配、操作的最小存储单元，与CPU的架构相关，通常有32字节、64字节、128字节等。经过大量实验取折中值为64字节。</p>
<ul>
<li>缓存行越大，局部性空间效率越高，但读取的时间就慢</li>
<li>缓存行越小，局部性空间效率越低，但读取的时间就快</li>
</ul>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>每个CPU都有自己的高速缓存，但又共享同一个主存。当多个处理器都涉及同一块主存区域的更改时，将导致各自的缓存数据不一致。因此提出缓存一致性协议来保证各处理器读取数据的一致性。</p>
<p>每个CPU厂商可能都有自己的缓存一致性协议。例如Intel的MESI协议。其他还有MSI、MOSI、MESIF、Synapse Firefly Dragon等。</p>
<p>MESI(Modified Exclusive Shared Or Invalid)</p>
<p><strong>MESI的状态</strong></p>
<p>CPU中的每个cache line使用4种状态标记（使用额外的两位(bit)来表示）：</p>
<p><strong>M：被修改（Modified）</strong></p>
<p>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，即与主存中的数据不一致，该缓存行中的内存需要在未来某个时间点写回主存。</p>
<p><strong>E：独享的(Exclusive)</strong></p>
<p>该缓存行<strong>只被缓存在该CPU的缓存</strong>中，<strong>它是未被修改过的，与主存中的数据一致</strong>。该状态可在任何时刻当有其他CPU读取该内存时变成共享状态（shared）。</p>
<p><strong>S：共享的（shared）</strong></p>
<p>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致，当有一个CPU修改该缓存行中的数据时，其他CPU中该缓存行可以被作废，变为Invalid状态。</p>
<p><strong>I：无效的（Invalid）</strong></p>
<p>该缓存是无效的（可能有其他CPU修改了该缓存行）</p>
<p>状态转换图及流程表</p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/MESI_pic.jpg" alt></p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/mesi_chart.png" alt></p>
<p>在一个典型系统中，可能会有几个缓存（在多核系统中，每个核心都会有自己的缓存）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了减少<code>CPU</code>读写共享主存的次数。</p>
<p>一个缓存除在<code>Invalid</code>状态外都可以满足cpu的读请求，一个<code>Invalid</code>的缓存行必须从主存中读取（变成<code>S</code>或者 <code>E</code>状态）来满足该<code>CPU</code>的读请求。</p>
<p>一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于<code>S</code>状态，必须先将其它缓存中该缓存行变成<code>Invalid</code>状态（也既是不允许不同<code>CPU</code>同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：<code>RequestFor Ownership</code> (<code>RFO</code>)。</p>
<p>缓存可以随时将一个非M状态的缓存行作废，或者变成<code>Invalid</code>状态，而一个<code>M</code>状态的缓存行必须先被写回主存。</p>
<p>一个处于<code>M</code>状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。</p>
<p>一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（<code>Invalid</code>）。</p>
<p>一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成<code>S</code>状态。</p>
<p>对于<code>M</code>和<code>E</code>状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而<code>S</code>状态可能是非一致的，如果一个缓存将处于<code>S</code>状态的缓存行作废了，而另一个缓存实际上可能已经</p>
<p>独享了该缓存行，但是该缓存却不会将该缓存行升迁为<code>E</code>状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的<code>copy</code>的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<p>从上面的意义看来E状态是一种投机性的优化：如果一个<code>CPU</code>想修改一个处于<code>S</code>状态的缓存行，总线事务需要将所有该缓存行的<code>copy</code>变成<code>Invalid</code>状态，而修改<code>E</code>状态的缓存不需要使用总线事务。</p>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>所谓的伪共享即指，在一个缓存行（缓存一致性协议针对的最小存取单元）内除了目标数据外可能还有其他的数据。如果多个核需要操纵这个缓存行内不同的数据就会使得效率变慢。</p>
<p>例如下图，变量x和变量y处于同一缓存行时，core1操作变量x，core2操作变量y。</p>
<p>流程即为：</p>
<ul>
<li><p>core1修改x后，按照一致性协议core2中的缓存行需要置为invalid，在core2需要的时候，core1将数据写回主存并通知core2重新读取</p>
</li>
<li><p>同理，core2修改y后，也要通知core1重新从主存读取。</p>
<p>就是在多核多线程并发场景下，多核需要操作不同变量位于同一个缓存行内的时候，会使得效率大打折扣。即为伪共享问题。</p>
<p><img src="/2020/06/03/%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/false_sharing.jpg" alt></p>
</li>
</ul>
<h3 id="常见解决方法"><a href="#常见解决方法" class="headerlink" title="常见解决方法"></a>常见解决方法</h3><h4 id="1-空间换时间（cache-line-padding）"><a href="#1-空间换时间（cache-line-padding）" class="headerlink" title="1.空间换时间（cache line padding）"></a>1.空间换时间（cache line padding）</h4><p>缓存行对齐（填充），即是当所需数据不足64字节时，用无意义的字节填满剩下的缓存行空间。</p>
<p>比如<strong>Disruptor</strong></p>
<p>disruptor是一个性能极强的开源<strong>无锁并发</strong>框架，基于Disruptor的LMAX架构交易平台，号称单线程内每秒可处理600万笔订单。</p>
<p>disruptor框架的核心是Ringbuffer环形缓冲。<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">github源码</a>，<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网</a>也有文章介绍该框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">// cache line padding</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> cursor = INITIAL_CURSOR_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> p8, p9, p10, p11, p12, p13, p14; <span class="comment">// cache line padding</span></span><br></pre></td></tr></table></figure>

<p>上述即为核心解决方案，long类型占用8个字节，在目标变量的前后定义多个无意义的变量进行填充，以空间换取时间。</p>
<p>以下进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_CacheLinePadding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//320-370~</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_CacheLinePadding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">8</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//220 - 250</span></span><br></pre></td></tr></table></figure>

<h4 id="2-JDK8中的注解-Contended"><a href="#2-JDK8中的注解-Contended" class="headerlink" title="2.JDK8中的注解@Contended"></a>2.JDK8中的注解@Contended</h4><p>JDK7中，大多采用long padding的方式提高效率，即缓存行对齐。但是不同的CPU所对应的缓存行大小可能不一致，因此在8中采用了此注解，针对不同的底层自动优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T05_CacheLinePadding</span> </span>&#123;</span><br><span class="line"><span class="meta">@Contended</span><span class="comment">//需要加上VM option：-XX：-RestrictContended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T05_CacheLinePadding t05 = <span class="keyword">new</span> T05_CacheLinePadding();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</span><br><span class="line">            t05.x = i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_0000_0000L</span>; i++) &#123;</span><br><span class="line">                t05.y = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println((end - start)/<span class="number">100_0000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加注解前平均1750</span></span><br><span class="line"><span class="comment">//加注解后平均580</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@Contended</span>注解的作用范围</span></span><br><span class="line"><span class="comment">//允许反射使用</span></span><br><span class="line"><span class="comment"><span class="doctag">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//作用范围：成员变量；类、接口（包括注解类型）后者是枚举类 </span></span><br><span class="line"><span class="comment"><span class="doctag">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计组</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】next导航栏404</title>
    <url>/2020/06/03/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404/</url>
    <content><![CDATA[<p>去查看了public下的index.html代码，发现所有导航路径后都有%20，%20代表空格，而这个一部分又是next主题中生成的，去查看了配置文件，将配置文件里 ||之前所有的空格删掉。</p>
<p><img src="/2020/06/03/%E3%80%90hexo%E3%80%91next%E5%AF%BC%E8%88%AA%E6%A0%8F404/pic1.jpg" alt></p>
<p>然后重新生成静态文件并部署即可。</p>
<p>侧边栏的链接可能也有404的问题，直接去主题目录下找相应名称的配置文件进行修改即可。</p>
<p>如果没有标签和分类页面，可以通过 hexo new page tags这样的命令在source下创建文件夹，并修改index.md<br>如下，冒号后面有空格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
